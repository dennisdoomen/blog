---

title: 
date: '2006-08-10T07:55:00.000+02:00'

tags: 
modified_time: '2006-08-10T09:25:44.053+02:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-115519474351683214
---


<strong><span style="color:#3366ff;">Introduction</span></strong><br /></span>The purpose of this series of posts is to list foundational principles, guidelines and tips that I use myself in my job as a .NET consultant. Based on these principles, I’ll write down several comprehensive guidelines that should help you to create well-designed classes and develop Windows Forms controls with rich design-time support. As an extra, I’ll include a list of books and URLs that I often use to help me to make the right choices. </span><br /><span style="font-size:0;"></span><br />With Foundational Principles, I mean the high-level principles that I consider while making decisions and choices during the creation of a design, the inspection of C# code, or the review of other people’s documents. Most of the other guidelines in this document find their origin in one of those principles.<br /><span style="font-size:0;"><br /><span style="font-size:130%;color:#3366ff;"><strong>Think in Objects</strong></span><br /><span style="font-size:100%;">Most classes should represent something that exists in the real world. It can be an object (file, drawer, report, book, car, company) or a concept (an ordering process, a performance approval from your boss, your salary, a model, a view, a controller). Every class should have characteristics and behaviour.<br />For instance, a class that must represent an employee or a manager could have been named Person. It may have several characteristics such as the person’s name, his birthday, his income per year, start date, and its role within the company, but it usually also has behaviour. Behaviour includes methods that you can call to determine his age (based on the person’s birthday and the current date), to remove the person from the system, or to determine whether the company employs any relatives. Additionally, if some rule exists that a manager must have been working for the company for at least 5 years, then that should be part of the class’s behaviour.<br />With the exception of utility classes, which merely represent a set of standalone functions, I usually start asking questions if I encounter a class with only static methods and properties. And, while recalling the Person example, if I find a method for calculating a person’s age on some other class, alarm bells go of immediately.</span><br /><br /><span style="font-size:130%;color:#3366ff;"><strong>Decoupling</strong></span><br /></span><span><span>It is a well-known fact that preventing tight coupling between classes will improve extensibility, maintainability and reviewability. A loosely coupled class can be replaced with another without the need to change any dependent classes. Also, for a reviewer or somebody that needs to fix a bug, it’s much easier to understand the design if he doesn’t have to inspect too many other classes. Especially bi-directional coupling (two classes that know each other) is strongly discouraged because it often introduces difficult dependencies in code.<br />There are several methods for ensuring loose coupling. In fact, many famous architects (Martin Fowler, Eric Gamma and friends) and Microsoft’s own Patterns & Practices team dedicate their work on identifying proper ways of solving common design problems. Indirection is a very good solution to allow a class to communicate with another class without the need to know what class that is exactly. Several design patterns are based on that concept, so I will provide some examples to make it a little bit more clear. </span></span><span style="font-size:0;"><br /></span><br /><span><strong>Indirection through interfaces</strong><br />In the Model-View Controller (MVC) pattern for example, the user interface layer is separated in a view class for pure presentation and a controller class for accessing the data layer and providing navigation between views. Typically, the view will use a specific technology (such as Windows Forms or ASP.NET), but the controller will not have any dependency. As such, the controller can be reused regardless of the technology.<br />The view will have a reference to the controller, but suppose you want to allow the controller to communicate with the view as well. How do you prevent the controller from accessing the view directly? Certainly, you could let the controller provide events to which the view can subscribe to. Whenever the controller has something to report, it raises the corresponding event. However, if there is a lot to report, you may end up with a lot of events. A better solution is to introduce an interface that the view implements and the controller can use. The class diagram below illustrates this. It still ensures decoupling, because even if you replace the view with a completely different implementation, as long as it implements that interface, the controller will stay unaffected. In both cases, the view must pass a reference to its interface to the controller (or delegate that to a third party).<br /></span><br /><span><strong>The Factory pattern</strong><br />Another example of decoupling is the Factory pattern. Suppose you have several classes that represent a task to perform (e.g. Task1, Task2, Task3). You want your application to execute such a task based on some logical name (derived from a menu or toolbar) without needing to know exactly which task class to use or what it does exactly.<br />You can solve that by introducing an interface or base class that all task classes implement, say ITask, and a separate class that has a method taking the logical name, say Factory. This method will contain the logic to instantiate the proper task class associated with the logical name. The logic to determine which exact class to instantiate is up to the factory class, but typically, it will use a large switch statement or an XML file containing the associations.<br />The application can then use the factory class for obtaining an implementation of ITask without knowing exactly which specific implementation it deals with.<br />Notice that a solution where things to do are represented by classes implementing an interface with some kind of Execute method is commonly referred to as the Command pattern. The interface is often called ICommand and a Factory is used to create the appropriate command for a logical name or other parameter. That’s why if you would replace the word Task with Command in the above diagram, you will end up with a typical example of this Command pattern. </span><br /><span style="font-size:0;"><br /></span><span><span><strong>Indirection through a Broker</strong><br />Suppose you introduce a class named Printer providing some kind of printer service and you want to provide this service to several parts of your applications without exposing the exact class. As illustrated by the class diagram below, you can solve this by refactoring the important functions of the service in a dedicated interface such as IPrintService. Upon start-up, the application can instantiate an instance of the Printer class and register it with a Broker class as the current implementation of the IPrintService interface. Any other part of your application will need to have access to the Broker class so that it can request the current print service. As such, a broker is nothing more than a class that maintains a list of interfaces with the run-time object implementing the interface. Again, decoupling is ensured because the application can dynamically register a different implementation of the IPrintService interface without changing any of the dependent code (a print to PDF service for instance). </span></span><span style="font-size:0;"><br /></span><br /><p><span><strong>Mediators</strong><br />To conclude the examples, assume you have two components, A and B, who need to exchange some data, but you do not want to have any coupling between them. The most obvious way of solving this, is to introduce another class that has access to both, and regulates data exchange through events and properties exposed by those components. A class like that is called a Mediator, and if you look closely at .NET, you will notice that a Form or a UserControl is actually the mediator for its child controls. </span><span style="font-size:0;"><br /><br /><strong><span style="font-size:130%;color:#3366ff;">Separation of Concerns</span></strong><br /></span><span><span>One of the most difficult aspects of a good object-oriented design is how to divide the responsibilities, or as I often call it, ensure separation of concerns. I always recommend starting with drawing out a draft on a piece of paper showing the main components and their responsibilities. Then, consider the most important functional and technical requirements one by one and determine which components will be involved and how. I generally use keywords to indicate which one will do what. Taking such an approach often helps you to quickly get a good idea on whether the design will do fine:It identifies the most important public interfaces. It clearly visualizes any classes that are too responsible, or the ones that have negligible responsibilities (other than container classes). It identifies controls that potentially may be combined in UserControls. It identifies bidirectional dependencies that need to be solved through indirection. It may help you to apply design patterns. If the design is complex, the next step is to create a technical design out of the draft you created earlier. Create high-level class diagrams and describe their interaction. Elaborate on the most important requirements and explain in words how the classes work together in fulfilling the requirement. I try to write a technical design on such an abstraction level that somebody who’s new in the team can read the document and understand the design choices I make without the need to study the code. On the other hand, it should also be written in such a way that the document stays current even if the code changes slightly. Therefore, the names of class members I show in class diagrams are mostly illustrative and are there to support the text around it. </span></span></p><p><strong><span style="color:#3366ff;">Reviewability &amp; Maintainability</span></strong><span style="font-size:0;"><br /></span><span><span>With everything I design or create, I keep reviewability and maintainability in mind, and they apply to both the code as well as the design.<br />Coding standards for example, help write code that looks the same regardless of who wrote it. They usually contain rules to prevent developers from making common mistakes or write code that may be misinterpreted easily. Some rules may even look like overkill but are intended to help a reviewer to understand that you thought something thoroughly through.<br />Class documentation (XML comments) should be written for the developer that will use your class, and if it is an interface, it should also make clear how to implement the interface. In both cases, the developer should be able to understand its purpose without the need to investigate the code. In-line comments should be used to explain what you are trying to accomplish with a block of statements, and more importantly, why you choose to solve it in a certain way. Especially if you deviate from an obvious solution, make sure that the comments explain why that solution was chosen over the obvious one.<br />Also, consider a less advanced solution. Not everybody can understand the abstraction or the orchestration of .NET Framework classes and interfaces your solution depends on. Consider splitting a complex statement over multiple lines to make them more readable, or add an extra comment.<br />All these same ideas also apply to technical designs. To name a few, make sure your document has a consistent look-and-feel (e.g. code examples, references to code elements, books, resources, etc). Before you start writing choose an appropriate abstraction level such as explained in the previous paragraph. Try to apply or refer to design patterns to make certain design choices more recognizable. Make clear what level of knowledge the reader should have to be able to understand it and refer to important books, articles, other documents. Focus on the requirements instead of simply listing classes with their members. </span></span></p>