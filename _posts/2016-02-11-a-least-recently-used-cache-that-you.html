---

title: A least recently used cache that you can use without worrying
date: '2016-02-11T19:14:00.001+01:00'

tags:
- fluid-caching
- open-source
- ravendb
- caching
- github
modified_time: '2016-08-10T11:27:40.005+02:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-3919770092860546580
blogger_orig_url: http://www.continuousimprover.com/2016/02/a-least-recently-used-cache-that-you.html
---

<p>At the beginning of this year, I <a href="http://www.continuousimprover.com/2016/01/evaluating-ravendb-as-embedded-database.html">reported</a> on my endeavors to use <a href="http://ravendb.net/">RavenDB</a> as a projection store for an event sourced system. One of the things I tried to speed up RavenDB's projection speed was to use the <a href="http://www.codeproject.com/Articles/23396/A-High-Performance-Multi-Threaded-LRU-Cache">Least Recently Used</a> cache developed by <a href="http://www.codeproject.com/script/Membership/View.aspx?mid=3034272">Brian Agnes</a> a couple of years ago. This cache gave us a nice speed increase, but the original author appears to be unreachable and seemingly abandoned the project. So I started looking for a way to distribute the code in a way that makes it painless to consume it in other projects. With this in mind, I decided to initiate a new open-source project <strong><a href="https://github.com/dennisdoomen/FluidCaching">Fluid Caching</a></strong>. As of August 10th, version 1.0.0 is officially available as a source-only package <a href="https://www.nuget.org/packages/FluidCaching.Sources/1.0.0">on NuGet</a>. <p><img style="float: none; margin-left: auto; display: block; margin-right: auto" src="https://www.asme.org/getmedia/fed5ad28-6224-4eab-a49b-ce110f7bc5ab/Taking_Science-hero.jpg.aspx" width="518" height="480">  <p>The cache in itself did meet our requirements quite well. It supported putting a limit on its capacity. It allows you to specify the minimum amount of time objects must be kept in the cache (even if that would exceed the capacity), as well as a maximum amount of time. It's completely safe to use in multi-threaded scenarios and is using an algorithm that keeps the performance under control, regardless of the number of items in the cache. It also supports multiple indexes based on different keys on top of the same cache, and is pretty flexible in how you get keys from objects. All credits for the initial implementation go to Brian, and I welcome you to read his original article from 2009 on some of the design choices.  <p><strong>What does it look like</strong>  <p>Considering a User class, in its simplest form, you can use the cache like this:  <p><font face="Courier New">var cache = new FluidCache&lt;User&gt;(1000, TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(10)), () =&gt; DateTime.Now);</font>  <p>This will create a cache with a maximum capacity of a 1000 items, but considering the minimum age of 1 minute, the actual capacity may exceed that for a short time. After an object hasn't been requested for as long as 10 minutes, it will be eligible for garbage collection. To retrieve objects from the cache, you need to create an index:  <p><font face="Courier New">IIndex&lt;User, string&gt; indexById = cache.AddIndex("byId", user =&gt; user.Id);</font>  <p>The lambda you pass in will be used to extract the key from the User object. Notice that you can have multiple indexes at the same time without causing duplication of the User instances. To retrieve an object from the cache (or create it on the spot), use the cache like this:  <p><font face="Courier New">User user = await indexById.GetItem("dennisd", id =&gt; Task.FromResult(new User { Id = id }));</font>  <p>Obviously, that factory will be invoked only once, and only if the object isn't in the cache already. The current API is async only, but as you can see, in those cases where usage of async/await is not really needed, it results in some ugly code. I'm considering to provide both a synchronous as well as an asynchronous API. Also, instead of passing the factory method in the call to GetItem, you can also pass a more global factory into the AddIndex method.  <p><strong>Why am I doing this</strong>  <p>Good question. It's 2016, so some of the custom thread synchronization primitives are part of the .NET framework these days. Next to that, we all write asynchronous code and thus have a need for support for async/await. These days, being able to compile the code against any modern .NET version, even a Portable Class Library or .NET Core, isn't a luxury either. Other features I'm adding include thread-safe factory methods and some telemetry for tuning the cache to your needs. In terms of code distribution, my preferred method for a library like this would be a source-only NuGet package so that you don't have to bother the consumers of your packages with another dependency. Also, the code quality itself needs some <a href="http://www.continuousimprover.com/2015/10/9-simple-practices-for-writing-better.html">Object Calisthenics</a> love as well as some sprinkles of my Coding Guidelines. And finally, you can't ship a library without at least a decent amount <a href="http://www.continuousimprover.com/2015/11/12-tips-to-write-unit-tests-that-dont.html">properly scoped unit tests</a> and a fully automated <a href="http://www.continuousimprover.com/2015/03/bringing-power-of-powershell-to-your.html">build pipeline</a>.  <p><strong>So how does it work</strong>  <p>As I mentioned before, I highly recommend the original article if you want to understand some of the design decisions, but let me share some of the inner workings right now. The FluidCache class is the centerpiece of the solution. It's more of a factory for other objects than a cache per see. Instead, all items in the cache are owned by the LifeSpanManager. Its responsibility is to track when item has been 'touched' and use that to calculate when it is eligible for garbage collection while accounting for the provided minimum age.  <p>Each item in the cache is represented by a Node, which on itself is part of a linked list of such nodes. The LifeSpanManager maintains an internal collection of 256 bags of which only one is open at the same time. Each bag has a limited lifetime and contains a pointer to the first node in the linked list. Whenever a new item is added to the cache, it is inserted into the head of the linked list. Similarly, if an existing item is requested, it is moved to the current bag as well. But whenever an item is added, requested or removed and a certain internal interval is passed, a (synchronous) clean-up operation is executed. This clean-up will iterate over all the bags, starting with the oldest one, and try to remove all nodes from that bag, provided that the bag's end-date matches the configured minimum and maximum age. When the clean-up has completed, the current bag is closed (it's end date and time is set) and the next one is marked as 'open'.  <p>Through the FluidCache class, you can create multiple indexes and provide an optional factory method. However, indexes are nothing more than simple dictionaries that connect the key of the index with a weak reference to the right node. They will never prevent the garbage collector for cleaning your item. Only after the LifeSpanManager removes the reference from its internal collection of aging bags, the GC can do its job.  <p>I'm not even close to an algorithmic magician, but I believe the project has a solid foundation. So check out the <a href="https://github.com/dennisdoomen/FluidCaching">code base</a> and let me know what you think. And follow me at <a href="https://twitter.com/ddoomen">@ddoomen</a> to get regular updates on my everlasting quest for better solutions. </p>