---

title: How Git can help you prevent building a monolith
date: '2016-02-04T20:00:00.001+01:00'

tags:
- TFS
- git
modified_time: '2016-02-10T07:14:58.143+01:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-5003475032780990620
blogger_orig_url: http://www.continuousimprover.com/2016/02/how-git-can-help-you-prevent-monolith.html
---

<p>During last weeks' <a href="http://www.slideshare.net/dennisdoomen/git-like-a-pro-how-to-use-it-as-it-was-meant-to">Git Like a Pro</a> talk I tried to convey the message that switching to <a href="https://git-scm.com/">Git</a> is much more than introducing a new source control system. It will affect not just the way you commit source code, branch or merge, it changes the entire development workflow. In fact, I'm willing to claim that switching from any centralized source control system to Git and a decent hosted Git service such as <a href="http://github.com/">GitHub</a>, <a href="https://bitbucket.org/">BitBucket</a> or <a href="https://about.gitlab.com/">GitLab</a> can help you to prevent building a monolith. Or maybe I should revert that claim by saying that <em>not</em> using hosted Git will make it a whole lot more difficult to prevent building monoliths. Why? Let me elaborate on this a bit.  <p><img style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; border-left: 0px; display: block; padding-right: 0px; margin-right: auto" border="0" src="http://tr1.cbsistatic.com/hub/i/2015/05/07/53aeae84-f486-11e4-940f-14feb5cc3d2a/networks-20110202.jpg"> <p>Preventing a monolith is difficult and painful, especially if the team is under a lot of pressure to release early and often. Technology like <a href="http://www.nuget.org/">NuGet</a> can help you to distribute components in a controlled way. And if that component needs to expose HTTP APIs, you can use <a href="http://continuousimprover.com/search/label/OWIN%20Recipes">OWIN</a> to host that NuGet component in virtually every kind of host. On an organizational level, you might be aware of <a href="http://www.continuousimprover.com/2015/03/a-scalable-software-development.html">Conway's Law</a> and decide to split your teams in a way that aligns with the envisioned components of your architecture. Physical boundaries will tend to cause your teams to introduce procedures and API contracts that formalize the interaction between those teams. However, that's, in my opinion, not enough.  <p>If I look back at my own projects, a recurring reason for not building some feature as a component is that would cause unexpected planning dependencies between the teams. So unless it was quite obvious that something could be built as a functional slice, we usually just build the feature into the existing codebase. So why this planning dependency? That's simple; because we were using Microsoft Team Foundation Server (TFS). TFS offers a nice and integrated collaboration environment for teams, but it used to offer a centralized source control system only. If you assign a team to own a particular component, usually maintained in a dedicated source code repository, only that team can make changes the component. Sure, you can grant access to other teams as well, but then you have no easy mechanism to control code changes that end up in the core code base.  <p>Considering planning dependencies, the worst thing that can happen to a team is that they have to wait for another team to finish a change request or bug report before they can continue. If your team practices an agile methodology like Scrum, it becomes very hard to plan for these things. Usually, this dependency doesn't popup until you start to work on some part of the code that relies on such a component. Unless the owning team has nothing planned that day, that user story that you carefully planned in your sprint planning meeting will get blocked for a couple of days. If your sprints only run for two weeks, being blocked in such a way is a significant impediment for high velocity teams.  <p>&nbsp;</p><img style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; border-left: 0px; display: block; padding-right: 0px; margin-right: auto" border="0" src="http://citygirlbites.com/blog/wp-content/uploads/2012/12/Stressed-Business-Woman.jpg" width="640" height="465"> <p>And even if that other team has plenty of time to spare, in most TFS projects, the release strategy for a component is everything but optimized. In many TFS projects I've seen, the most advanced thing they do is to add the change set number of the last source control change to the component version. Anything more advanced than that is pretty painful with TFS's build system. So what is it that Git and hosted Git services offer that TFS doesn't? I’ve already blogged <a href="http://www.continuousimprover.com/2015/06/why-you-should-abandon-tfs-source.html">about this</a> last year, but those that are essential are… pull requests and forking. <p>Forking a repository on GitHub means that you're going to create a clone of the original source code repository that is stored under your own account. The crucial feature here is that GitHub will create a link between your clone and the original repository. Your clone gets all the branches and tags from that original and you're free to create new branches, experiment with the original code base and do other advanced stuff like rebasing. All without affecting the original repo.  <p>You could add some new extension point to the original code or fix that bug that you found while your team was working on some code changes. If the owners of the original repo added build scripts such as <a href="http://www.continuousimprover.com/2015/03/bringing-power-of-powershell-to-your.html">PSake</a> as part of the source, you can even build a NuGet package from it and use that for the time being. Now, if you're confident that the bug was fixed, or that new extension point serves its purpose well, it's time for that pull request. With such a PR, you're asking the owners of the original owners to pull your changes into the official code base. The PR serves as a central point for discussions, and code reviews, and may even include status changes and unit test results from their build system. In essence, forking and PRs facilitate the autonomy needed for successful agile teams. You're never blocked by the other team simply because you can alter the code to your need without going in separate ways. That on itself, is a crucial ingredient for component-driven development in emergent architectures. And I haven't even started about advanced Git-only <a href="http://www.continuousimprover.com/2015/04/software-versioning-without-thinking.html">release strategies</a> such as GitFlow and GithubFlow or automatic versioning through <a href="http://www.continuousimprover.com/2015/04/software-versioning-without-thinking.html">GitVersion</a>.  <p>Now, some of the TFS proponents around me might say that TFS has supported Git as a source control system for a couple of years now. Hey, they may even tell you that TFS offers pull requests these days. But, it does not support creating cross-repository pull requests yet. Don't get me wrong though. This blog is not a rant against TFS. But over the last two years I've come to realize that we have been held back significantly by using TFS. And although I fully realize that Microsoft has pushed a lot of new features to TFS over the last year or so, we <a href="https://twitter.com/tfsbuck/status/694846272008642560">still</a> miss that crucial feature.  <p>If it's up to me, TFS is not a viable option for large-scale agile development anytime soon. So what do you think? Let me know by commenting below. And follow me at <a href="https://twitter.com/ddoomen">@ddoomen</a> to get regular updates on my everlasting quest for better solutions. </p>