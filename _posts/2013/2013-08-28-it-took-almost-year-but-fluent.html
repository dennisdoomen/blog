---

title: It took almost a year, but Fluent Assertions 2.1 is done
date: '2013-08-28T07:21:00.001+02:00'

tags:
- Fluent Assertions
modified_time: '2013-08-28T07:21:45.610+02:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-2008526190796869789
blogger_orig_url: http://www.continuousimprover.com/2013/08/it-took-almost-year-but-fluent.html
---

<p>It has been way too long since I last released a new version of Fluent Assertions, but somehow my intention to deliver at least every three months has once again failed by the obligations a working husband and father of two has. Nonetheless, <a href="https://github.com/dennisdoomen/fluentassertions/releases/tag/v2.1">Fluent Assertions 2.1</a> is a fact. And although it isn't such a big release as 2.0, somehow it has accumulated a lot of nice improvements. As always you'll find the detailed release notes on the <a href="https://www.nuget.org/packages/FluentAssertions">NuGet landing page</a>, but just for the fun of it, let me provide some background on some of the changes 2.1 introduces.  <p>For instance, the primary reason why this release took so long was the amount of work required to add the following two improvements to the structural equality assertions; reporting all differences and order independence. Those two required me to almost completely rewrite the internal engine. You may think "How difficult can that be?", but order independence between collections requires FA to compare each item from the subject collection with each item from the expected collection. Now consider that comparing two items might actually involve comparing two object graphs as well. If you find an exact match, all is fine. But what if there's no exact match? Which object graph should FA use for reporting the differences? I decided to solve this problem by selecting the object graph with the least amount of differences compared to the expectation. It will not always give you the perfect result (what if two items result in the exact same number of differences?), but chances are you'll get enough information to fix your code. As an example, consider the following scenario: <pre class="csharpcode">var subject = <span class="kwrd">new</span> <br />{ <br />  Property1 = <span class="str">"A"</span>, <br />  Property2 = <span class="str">"B"</span>, <br />  SubType1 = <span class="kwrd">new</span> <br />  { <br />     SubProperty1 = <span class="str">"C"</span>, <br />     SubProperty2 = <span class="str">"D"</span>, <br />  } <br />}; <br /><br />var expectation = <span class="kwrd">new</span> <br />{ <br />  Property1 = <span class="str">"1"</span>, <br />  Property2 = <span class="str">"2"</span>, <br />  SubType1 = <span class="kwrd">new</span> <br />  { <br />    SubProperty1 = <span class="str">"3"</span>, <br />    SubProperty2 = <span class="str">"D"</span>, <br />  } <br />}; </pre><br /><style type="text/css">.csharpcode, .csharpcode pre<br />{<br />	font-size: small;<br />	color: black;<br />	font-family: consolas, "Courier New", courier, monospace;<br />	background-color: #ffffff;<br />	/*white-space: pre;*/<br />}<br />.csharpcode pre { margin: 0em; }<br />.csharpcode .rem { color: #008000; }<br />.csharpcode .kwrd { color: #0000ff; }<br />.csharpcode .str { color: #006080; }<br />.csharpcode .op { color: #0000c0; }<br />.csharpcode .preproc { color: #cc6633; }<br />.csharpcode .asp { background-color: #ffff00; }<br />.csharpcode .html { color: #800000; }<br />.csharpcode .attr { color: #ff0000; }<br />.csharpcode .alt <br />{<br />	background-color: #f4f4f4;<br />	width: 100%;<br />	margin: 0em;<br />}<br />.csharpcode .lnum { color: #606060; }<br /></style><br /><br /><p>Calling subject.ShouldBeEquivalentTo(expectation ) will result in the following test failure <br /><p><font size="2" face="Consolas">Expected property Property1 to be "1", but "A" differs near "A" (index 0). <br></font><font size="2" face="Consolas">Expected property Property2 to be "2", but "B" differs near "B" (index 0). <br></font><font size="2" face="Consolas">Expected property SubType1.SubProperty1 to be "3", but "C" differs near "C" (index 0). </font></p><br /><p><font size="2" face="Consolas">With configuration: <br></font><font size="2" face="Consolas">- Select all declared properties <br></font><font size="2" face="Consolas">- Match property by name (or throw) <br></font><font size="2" face="Consolas">- Invoke Action&lt;DateTime&gt; when info.RuntimeType.IsSameOrInherits(System.DateTime) <br></font><font size="2" face="Consolas">- Invoke Action&lt;String&gt; when info.RuntimeType.IsSameOrInherits(System.String)</font> </p><br /><p>Supporting aggregated exceptions was another of those little challenges. What I tried to accomplish is that the various <strong>ShouldThrow </strong>and <strong>ShouldNotThrow</strong> overloads would intercept any <strong>AggregateException</strong> instances and apply the assertion on the exceptions within. So from an end-user perspective it shouldn't matter if some expected or unexpected exception is first wrapped in an <strong>AggregateException</strong>. The less trivial part involved adding that behavior without breaking the .NET 3.5 and Silverlight versions (they share the same extension methods). Using the <a href="http://en.wikipedia.org/wiki/Strategy_pattern">Strategy Pattern</a> by means of an <strong>IExtractExceptions</strong> interface allowed me to plug in a framework-specific version of Fluent Assertions. <br /><p>And while I was looking at exceptions anyway, I decided to change the way exception messages are asserted. In version 2.0 you had the option to specify how FA should interpret the <strong>WithMessage</strong> extension method. Having worked with this for a while in our own project (with 6000 unit tests) I came to the conclusion that you should really never want to check the exception message using an exact case-sensitive match. Doing that would only result in very brittle unit tests. As a result of this, I decided that as of version 2.1, the <strong>ComparisonMode</strong> is obsolete and any assertions against the exception message is treated as a case-insensitive wildcard match. <br /><p>So what's next? Well, before including those little feature requests waiting on the <a href="https://github.com/dennisdoomen/FluentAssertions/issues?milestone=none&amp;state=open">issue list</a>, I have two important steps to complete. <br /><p><strong>Move to GitHub <br></strong>I've long hoped that Microsoft's approach embracing the open-source mindset would provide the CodePlex team with the resources to make it a first-class hub for open-source projects. Support for Git was a major step, but the lack of any big improvements for over a year is what made me decide to move to GitHub. The source code and binaries have already been moved to its new home, but I still need to clean up the documentation and find a definite place for downloading <br /><p><strong>Switch to Portable Class Libraries <br></strong>Supporting multiple versions of FA has always been a pain, even while using linked source files. Especially during the many internal redesigns of 2.1, I got sick of constantly having to fix-up renames of classes or copy an added file into all other projects. I'm not 100% sure if PCLs will solve all problems, but I will give it a try anyhow.</p>  