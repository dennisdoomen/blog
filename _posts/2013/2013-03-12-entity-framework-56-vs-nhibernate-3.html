---

title: Entity Framework 5 and 6 vs NHibernate 3 – The State of Affairs
date: '2013-03-12T20:48:00.001+01:00'

tags:
- Visual Studio
- C#
- Architecture
modified_time: '2014-02-06T20:41:19.904+01:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-6759773618352053729
blogger_orig_url: http://www.continuousimprover.com/2013/03/entity-framework-56-vs-nhibernate-3.html
---

<p>It has been <a href="http://www.dennisdoomen.net/2010/03/is-entity-framework-40-ready-for-real.html">almost two years</a> since I've last compared NHibernate and Entity Framework, so with the recent <a href="http://blogs.msdn.com/b/adonet/archive/2013/02/27/ef6-alpha-3-available-on-nuget.aspx">alpha version</a> of EF 6, it's about time to look at the current state of affair. I've been using NHibernate for more than 6 years so obviously I'm a bit biased. But I can't ignore that EF's feature list is growing and some of the things I like about the NHibernate eco-system such as code-based mappings and automatic migrations have found a place in EF. Moreover, EF is now <a href="http://entityframework.codeplex.com/">open-source</a>, so they're accepting <a href="http://entityframework.codeplex.com/sourcecontrol/list/contributions">pull requests</a> as well. </p> <p>Rather than doing a typical feature-by-feature comparison, I'll be looking at those aspects of an object-relational mapper that I think are important when building large-scale enterprise applications. So let's see how those frameworks match up. Just for your information, I've been looking at <a href="http://blogs.msdn.com/b/adonet/archive/2013/02/27/ef6-alpha-3-available-on-nuget.aspx">Entity Framework 6 Alpha 3</a> and <a href="http://nhforge.org/">NHibernate 3.3.1GA</a>. </p> <p><strong>Support for rich domain models</strong> <br>When you're practicing Domain Driven Design it is crucial to be able to model your domain using the right object-oriented principles. For example, you should be able to encapsulate data and only expose properties if that is needed by the functional requirements. If you model an association using a UML <a href="http://www.sparxsystems.com/enterprise_architect_user_guide/modeling_languages/qualifiers.html">qualifier</a>, you should be able to implement that using a <span style="font-family: consolas">IDictionary&lt;T,T&gt;</span>. Similarly, collection properties should be based on <span style="font-family: consolas">IEnumerable&lt;T&gt;</span> or any of the newer <a href="http://visualstudiomagazine.com/articles/2012/08/07/new-read-only-collection-interfaces-for-net.aspx">read-only collections</a> introduced in .NET 4.5 so that your collections are protected by external changes. </p> <p>NHibernate supports all these requirements and adds quite a <a href="http://nhibernate.hibernatingrhinos.com/17/mapping-collections-in-nhibernate-part-1">lot of flexibility</a> like ordered and unordered sets. Unfortunately, neither EF5 or 6 supports mapping private fields (<a href="http://entityframework.codeplex.com/wikipage?title=Design%20Meeting%20Notes%20-%20February%2020,%202013">yet</a>) nor can you directly use a dictionary class. In fact, EF only supports <span style="font-family: consolas">ICollections</span> of entities, so collections of <a href="http://devlicio.us/blogs/casey/archive/2009/02/13/ddd-entities-and-value-objects.aspx">value objects</a> are out of the question. One notable type that still isn't fully supported is the enum. It was introduced in EF5, but only if you target .NET 4.5. EF6 will fortunately fixes this so that it is also available in .NET 4.0 applications. </p> <p>A good ORM should also allow your domain model to be as <a href="http://programmers.stackexchange.com/questions/181931/do-we-achieve-100-persistence-ignorance-solution-if-were-not-using-orms-poco">persistence ignorant</a> as possible. In other words, you shouldn't need to decorate your classes with attributes or subclass some framework-provided base-class (something you might remember from Linq2Sql). Both frameworks impose some limitations such as protected default constructors or virtual members, but that's not going to be too much of an issue. </p> <p><strong>Vendor support</strong> <br>Although Microsoft makes us believe that corporate clients only use SQL Server or SQL Azure, we all know that the opposite is much more true. The big drawback of EF compared to NH is that the latter has all the providers built-in. So whenever a new version of the framework is released you don't have to worry about vendor support. </p> <p>Both EF5 and NH 3.3 support various flavors of SQL Server/Azure, SQLite, PostgreSQL, Oracle, Sybase, Firebird and DB2. Most of these providers originate from EF 4, so they don’t support code-first (migrations) or the new DBContext façade. EF6 is still an alpha release and its provider model seems to contain some breaking changes so don't expect any support for anything other than Microsoft's own databases anytime soon. </p> <p><strong>Support switching databases for automated testing purposes</strong> <br>Our architecture uses a repository pattern implementation that <a href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=84">allows swapping</a> the actual data mapper on-the-fly. Since we're heavily practicing Test Driven Development, we use this opportunity to approach our testing in different ways. </p> <ol> <li>We use an in-memory Dictionary for unit tests where the subject-under-test simply needs some data to be setup in a specific way (using <a href="http://nat.truemesh.com/archives/000714.html">Test Data Builders</a>).  <li>We use an in-memory SQLite database when we want to verify that NHibernate can process the LINQ query correctly and performs sufficiently using <a href="http://www.hibernatingrhinos.com/products/nhprof">NHProf</a>.  <li>We use an actual SQL Server for unit tests that verify that our mapping against the database schema is correct.  <li>We have some integration code that interacts with a third-party Oracle system that is tested on SQL Server on a local development box, but uses Oracle on our automated <a href="http://www.specflow.org/specflownew/">SpecFlow</a> build.</li></ol> <p>So you can imagine switching between database providers without changing the mapping code is quite essential for us. </p> <p>During development, we decided that we did not care about the actual class that represented the integration tables, so we tried to use the Entity Framework model-first approach. Unfortunately, when you do that, you're basically locking yourself to a particular database. After switching back to our normal NHibernate approach, changing the connection string during deployment was enough to switch between SQL Server and Oracle. Fortunately this has also been possible since EF 4.1 and Jason Short wrote a <a href="http://infinitecodex.com/infinitecodex/post/2011/03/22/Using-EF-41-Code-First-to-support-multiple-database-vendors.aspx">good</a> blog post about that. </p> <p><strong>Automatic schema migration</strong> <br>When you're practicing an agile methodology such as Scrum, you'll probably try to deliver a potentially shippable release at the end of every sprint. Part of being agile is that functionality can be added at any time where some of that might be affecting the database schema. The most traditional way of dealing with that is to generate or hand-write SQL scripts that are applied during deployment. The problem with SQL scripts is that they are tedious to write, might contain bugs, and are often closely coupled to the database vendor. Wouldn't it be great if the ORM framework would support some way of figuring out what version of the schema is being used and automatically upgrade the database scheme as part of your normal development cycle? Or what about the ability to revert the schema to an older version? </p> <p>The good news that this exists for both frameworks, but with a caveat. For instance, NHibernate doesn't support this out-of-the-box (although you can generate the initial schema). But with the help of another open-source project, <a href="https://github.com/schambers/fluentmigrator/wiki">Fluent Migrations</a>, you can get very far. We currently use it in an enterprise system and it works like a charm. The caveat is that the support for the various databases is not always at the same level. For instance, SQLite doesn't allow renaming a column and Fluent Migrations doesn't support it (although theoretically it could create a new column, copy the old data over, and drop the old column). As an example of a fluent migration supporting both an update as well as a rollback, check out this snippet.</p><pre class="csharpcode"><span style="font-size: x-small">[Migration(1)]<br><span class="kwrd">public</span> <span class="kwrd">class</span> TestCreateAndDropTableMigration: Migration<br>{<br>    <span class="kwrd">public</span> <span class="kwrd">override</span> <span class="kwrd">void</span> Up()<br>    {<br>        Create.Table(<span class="str">"TestTable"</span>)<br>            .WithColumn(<span class="str">"Id"</span>).AsInt32().NotNullable().PrimaryKey().Identity()<br>            .WithColumn(<span class="str">"Name"</span>).AsString(255).NotNullable().WithDefaultValue(<span class="str">"Anonymous"</span>);<br><br>        Create.Table(<span class="str">"TestTable2"</span>)<br>            .WithColumn(<span class="str">"Id"</span>).AsInt32().NotNullable().PrimaryKey().Identity()<br>            .WithColumn(<span class="str">"Name"</span>).AsString(255).Nullable()<br>            .WithColumn(<span class="str">"TestTableId"</span>).AsInt32().NotNullable();<br><br>        Create.Index(<span class="str">"ix_Name"</span>).OnTable(<span class="str">"TestTable2"</span>).OnColumn(<span class="str">"Name"</span>).Ascending()<br>            .WithOptions().NonClustered();<br><br>        Create.Column(<span class="str">"Name2"</span>).OnTable(<span class="str">"TestTable2"</span>).AsBoolean().Nullable();<br><br>        Create.ForeignKey(<span class="str">"fk_TestTable2_TestTableId_TestTable_Id"</span>)<br>            .FromTable(<span class="str">"TestTable2"</span>).ForeignColumn(<span class="str">"TestTableId"</span>)<br>            .ToTable(<span class="str">"TestTable"</span>).PrimaryColumn(<span class="str">"Id"</span>);<br><br>        Insert.IntoTable(<span class="str">"TestTable"</span>).Row(<span class="kwrd">new</span> { Name = <span class="str">"Test"</span> });<br>    }<br>    <br>    <span class="kwrd">public</span> <span class="kwrd">override</span> <span class="kwrd">void</span> Down()<br>    {<br>        Delete.Table(<span class="str">"TestTable2"</span>);<br>        Delete.Table(<span class="str">"TestTable"</span>);<br>    }<br>}</span></pre><br /><p><br><br>Entity Framework has something similar built-in since version 5. It's called <a href="http://msdn.microsoft.com/en-US/data/jj591621">Code-First Migrations</a> and looks surprisingly similar to Fluent Migrations. Just like the NHibernate solution has some limitations, EF's has as well and that is support from vendors. At the time of this writing not a single vendor supports Code-First Migrations. On the other hand, if you're only using SQL Server, SQL Express, SQL Compact or SQL Azure, there's nothing from stopping you to use it.</p><br /><p><strong>Code-based mapping<br></strong>If you remember the old days of NHibernate, you might recall those ugly XML files that were needed to configure the mapping of your .NET classes to the underlying database. <a href="http://www.fluentnhibernate.org/">Fluent NHibernate</a> has been offering a very nice fluent API for replacing those mappings with code. Not only does this prevent errors in the XML, it is also a very refactor-friendly approach. We've been using it for years and the extensive (and customizable) <a href="https://github.com/jagregory/fluent-nhibernate/wiki/Conventions">convention-based</a> mapping engine even allows <a href="https://github.com/jagregory/fluent-nhibernate/wiki/Auto-mapping">auto-mapping</a> entities to tables without the need of explicit mapping code. </p><br /><p>Strangely enough, NHibernate 3.2 has introduced a brand new fluent API that directly competes with Fluent NHibernate. Because of lack of documentation, I've never bothered to look at it, especially since Fluent NHibernate has been doing its job remarkedly. But during my research for this post I noticed that Adam Bar has written a <a href="http://notherdev.blogspot.nl/2012/02/nhibernates-mapping-by-code-summary.html">very extensive series</a> on the new API, and he actually managed to raise a renewed interest in the new API. </p><br /><p>Until Entity Framework 4.1 the only way to set-up the mapping was through its data model designer (not to be confused with an OO designer). But apparently the team behind it learned from Fluent Nhibernate and decided to introduce their own code-first approach, surprisingly named Code-First. In terms of convention-based mapping, it was quite limited, especially compared to Fluent NHibernate. EF 6 is going to introduce a lot of hooks for changing the conventions, both on property level as well as on class level. </p><br /><p><strong>Supporting custom types and collections<br></strong>One of the guidelines in my own <a href="http://csharpguidelines.codeplex.com/">coding guidelines</a> is to consider wrapping primitive types with more domain-specific types. Conincedentily it is also one of the rules of <a href="http://www.bennadel.com/resources/uploads/2012/ObjectCalisthenics.pdf">Object Calisthenetics</a>. In Domain Driven Design these types are called <a href="http://devlicio.us/blogs/casey/archive/2009/02/13/ddd-entities-and-value-objects.aspx">Value Objects</a> and their purpose is to encapsulate all the data and behavior associated with a recurring domain concept. For instance, rather than having two separate <span style="font-family: consolas">DateTime</span> properties to represent a period and separate methods for determining whether some point of time occurs within that period, I would prefer to have a dedicated <span style="font-family: consolas">Period</span> class that contains all that logic. This approach results in a design that contains less duplication and is easier to understand. </p><br /><p>Contrary to NHibernate, Entity Framework doesn't offer anything like this and as far as I know, doesn't plan to. NH on the other hand offers a myriad of options for creating custom types, custom collections or even composite types. Granted, you have to do a bit of digging to find the right documentation (and <a href="http://stackoverflow.com/questions/tagged/nhibernate">StackOverflow</a> is your friend here), but if you do, it really helps to enrich your domain model. </p><br /><p><strong>Query flexibility<br></strong>Some would argue that EF's LINQ support is much more mature, and until NH 3.2 I would have agreed. But since then, NH's LINQ support has improved substantially. For instance, during development we use an in-memory SQLite database in our query-related unit tests to make sure the query can actually be executed by NH. Before 3.2, we regularly ran into strange cast exceptions or exceptions because of unsupported expressions. Since 3.2, we've never seen those anymore. </p><br /><p>I haven't tried to run all our existing queries against EF, but I have no doubts that it would have any issue with it. In terms of non-LINQ querying, EF supports <a href="http://msdn.microsoft.com/en-us/library/bb387145.aspx">Entity SQL</a> as well as native SQL (although I don’t know if all vendors are supported). NHibernate offers the HQL, <a href="http://nhforge.org/blogs/nhibernate/archive/2009/12/17/queryover-in-nh-3-0.aspx">QueryOver</a> and Criteria APIs next to native vendor-specific SQL. Both frameworks support stored procedures. All in all plenty of flexibility. </p><br /><p><strong>Extensibility<br></strong>EF 6 uses the <a href="http://entityframework.codeplex.com/wikipage?title=EF%20Configuration%20and%20Extensibility">service locator</a> pattern to allow replacing certain aspects of the framework at runtime. This is a good starting point for extensibility, but unfortunately the team always demonstrates this by replacing the pluralization service. As if someone would actually like to do that. Nonetheless, I'm sure the team's plan is to expose more extension points in the near future. </p><br /><p>NH has a very extensive set of observable collections called <a href="https://www.google.com/search?q=nhibernate+listeners">listeners</a> that can be used to hook into virtually every part of the framework. We've been using it for cross-cutting concerns, for hooking up auditing services and also for some CQRS related aspects. You can also tweak a lot of NH's behavior through <a href="http://elliottjorgensen.com/nhibernate-api-ref/NHibernate.Cfg/Environment.html">configuration properties</a> (although you'll have to Google…eh…Bing for the right examples). </p><br /><p><strong>Other notable features<br></strong>Each of the frameworks has some unique features that don't fit in any of the other topics I've discussed up to now. A short summary:</p><br /><ul><br /><li>Entity Framework 6 adds <span style="font-family: consolas">async</span>/<span style="font-family: consolas">await</span> support, a feature that NHibernate may never get due to the impact it has on the entire architecture.<br><br /><li>It also has built-in support for automatically reconnecting to the database, which is particularly useful for a known issue with SQL Azure.<br><br /><li>Both NHibernate as well as the Entity Framework support .NET 4.5, but only the latter gains some significant performance improvements from it. <br><br /><li>NHibernate has a unique selling point and that is its very advanced and pluggable <a href="http://ayende.com/blog/3112/nhibernate-and-the-second-level-cache-tips">2nd level cache</a>. This has allowed significant performance improvements in one of our projects, simply by caching reference data. <br><br /><li>NHibernate offers another unique feature called <a href="http://ayende.com/blog/3979/nhibernate-futures">Futures</a> that you can use to compose a set of queries and send them to the database as a single request.<br><br /><li>The Entity Framework allows creating a <span style="font-family: consolas">DBContext</span> with an existing open connection. As far as I know that's not possible in NHibernate. <br><br /><li>Version 6 of the Entity Framework adds spatial support, something for which you need a 3rd party library to get that in NHibernate. Pedro Sousa wrote an <a href="http://build-failed.blogspot.nl/2012/02/nhibernate-spatial-part-1.html">in-depth</a> blog post series about that.</li></ul><br /><p><br><strong>Wrap-up<br></strong>The big difference between Entity Framework and NHibernate from a developer perspective is that the former offers an integrated set of services whereas the latter requires the combination of several open-source libraries. That on itself is not a big issue - that's why we have <a href="http://nuget.org/">NuGet</a>, don't we? - but we've noticed that those libraries are not always up-to-date soon enough when new NHibernate versions are released.</p><br /><p>From that same perspective NHibernate does offer a lot of flexibility and clearly shows its maturity. On the other hand, you could also see that as a potential barrier for new developers. It's just much easier to get started with Entity Framework than with NH. The documentation on Entity Framework is quite comprehensive and even the new functionality for version 6 is extensively documented using <a href="http://entityframework.codeplex.com/wikipage?title=specs">feature specifications</a>. The NHibernate <a href="https://github.com/nhibernate/nhibernate-core">documentation</a> has always been lagging behind a bit. For instance, the new mapping system is not even mentioned even though the reference documentation mentions the correct version. The information is available, but you just have to search a bit.</p><br /><p>The fact that the EH is being developed using a Git source control <a href="http://entityframework.codeplex.com/SourceControl/changeset/view/e95ca12e5ae6">repository</a> is also a big plus. Just look at the <a href="http://entityframework.codeplex.com/wikipage?title=specs">many pull requests</a> they've been taking in. On the other hand, to my surprise somebody moved the NHibernate source code to GitHub while I wasn't paying attention. So on that aspect they are equals.</p><br /><p>And does NHibernate have a future at all? Some would <a href="http://notherdev.blogspot.nl/2012/09/is-nhibernate-dead.html">argue</a> it is dead already. I don't agree though. Just look at the <a href="https://github.com/nhibernate/nhibernate-core/graphs">statistics</a> on GitHub; 240 forks, almost 200 pull requests and a lot of commits in the last few months. I do agree that NoSQL solutions like <a href="http://ravendb.net/">RavenDB</a> are extremely powerful and offer a lot of fun and flexibility for development, but the fact of the matter is that they are still not widely accepted by enterprises with a history in SQL Server or Oracle. </p><br /><p>Nevertheless, the RAD aspect of EF cannot be ignored and is important for small short-running projects where SQL Server is the norm. And for those projects, I would wholeheartedly recommend EF. But for the bigger systems where a NoSQL solution is not an option, especially those based on Domain Driven Design, NHibernate is still the king in town.</p><br /><p>As usual, I might have overlooked a feature or misinterpreted some aspect of both frameworks. If so, leave a comment, email me or drop me a tweet at <a href="https://twitter.com/ddoomen">@ddoomen</a>.</p>  