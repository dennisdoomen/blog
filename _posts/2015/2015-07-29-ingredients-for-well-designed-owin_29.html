---

title: Ingredients for well-designed OWIN middleware components - Part 7
date: '2015-07-29T11:28:00.004+02:00'

tags:
- OWIN Recipes
modified_time: '2015-10-09T10:08:48.169+02:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-4029759629827470633
blogger_orig_url: http://www.continuousimprover.com/2015/07/ingredients-for-well-designed-owin_29.html
---

<div style="margin: 0in;"><span style="font-family: inherit;">In the </span><a href="http://www.continuousimprover.com/2015/07/ingredients-for-well-designed-owin_27.html" style="font-family: inherit;">sixth post</a><span style="font-family: inherit;"> of this series I talked about how you can use Swagger to create real&nbsp;</span>useful<span style="font-family: inherit;">&nbsp;documentation&nbsp;for your API. In this seventh and probably last post, I'd like to present some spices to make that OWIN middleware component extra special. </span></div><div style="margin: 0in;"><br /></div><div style="margin: 0in;"><span style="font-weight: bold;"><span style="font-family: inherit;">Spice 1: Automate your entire build process using PSake</span></span></div><div style="margin: 0in;"><span style="font-family: inherit;">So you've completed the first version of your component and you're ready to ship it as a NuGet package. Manually creating that </span><span style="font-family: Courier New, Courier, monospace;">.nuspec</span><span style="font-family: inherit;"> file, running </span><span style="font-family: Courier New, Courier, monospace;">nuget.exe</span><span style="font-family: inherit;"> and publishing it to nuget.org is not that difficult to do. But now what? Are you going to do it like that forever? Of course not. That's why we have the <a href="http://www.continuousimprover.com/2015/03/bringing-power-of-powershell-to-your.html">power of PowerShell</a> to our disposal, something that I already demonstrated with <a href="http://www.continuousimprover.com/2015/07/ingredients-for-well-designed-owin_10.html">ingredient 6</a>. </span></div><div style="margin: 0in;"><br /></div><div style="margin: 0in;"><span style="font-weight: bold;"><span style="font-family: inherit;">Spice 2: Choose the right release strategy</span></span></div><div style="margin: 0in;"><span style="font-family: inherit;">Now that you have your first release out of the door, you'll have to start thinking about when and how you're going to release feature versions of your component. Is any change you make that good that you can ship right away? Or do you first want to stabilize upcoming releases by shipping alpha or beta packages to be tested by your consumers. Within the git open-source world, two strategies have become kind of ad-hoc standards. There's a lot of <a href="http://gitversion.readthedocs.org/en/latest/git-branching-strategies/">documentation available</a>, but the gist of it is that you should <a href="http://gitversion.readthedocs.org/en/latest/git-branching-strategies/githubflow/">GitHubFlow</a>if every change you do is production ready and <a href="http://gitversion.readthedocs.org/en/latest/git-branching-strategies/gitflow/">GitFlow</a>if you work on multiple features in parallel and get released after a period of testing. In both scenarios, <a href="https://github.com/GitTools/GitVersion">GitVersion</a>will help you automatically generate version numbers, just <a href="https://github.com/dennisdoomen/piercer/blob/master/Build/default.ps1#L39">like I do</a> in Piercer.</span></div><div style="margin: 0in;"><br /></div><div style="margin: 0in;"><span style="font-family: inherit;"><span style="font-weight: bold;">Spice 3: Decoupling through delegates</span> </span></div><div style="margin: 0in;"><span style="font-family: inherit;">In <a href="http://www.continuousimprover.com/2015/07/ingredients-for-well-designed-owin_10.html">ingredient 6</a> I talked about the example of having your component support an extension point in the form of the </span><span style="font-family: Courier New, Courier, monospace;">IPlugin</span><span style="font-family: inherit;"> interface. I suggested to put that interface in a separate NuGet package so that your extension point doesn't need to take a dependency on the middleware component package. An alternative approach for using an interface is to define the contract in the form of a delegate. So instead of taking the (simplified) interface definition…</span></div><div style="margin: 0in;"><br /></div><div style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">public interface IPlugin<br />{</span></div><div style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">&nbsp; bool IsMatch(Assembly assembly);<br />}</span></div><div style="margin: 0in;"><br /></div><div style="margin: 0in;"><span style="font-family: inherit;">…you can have the middleware component also take a delegate like this:</span></div><div style="margin: 0in;"><br /></div><div style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">public delegate bool AssemblyMatcher(Assembly assemby);</span></div><div style="margin: 0in;"><br /></div><div style="margin: 0in;"><span style="font-family: inherit;">By doing so, any method that matches that signature can be passed in place of the delegate, thereby removing the need for the plugin to implement an interface or taking a dependency at all. Delegates exist since .NET 1.0, but somehow they didn't get the love they deserved.</span></div><div style="margin: 0in;"><br /></div><div style="margin: 0in;"><span style="font-weight: bold;"><span style="font-family: inherit;">Spice 4: Logging like a master</span></span></div><div style="margin: 0in;"><span style="font-family: inherit;">Now suppose your middleware component needs some kind of logging feature to help diagnosing production issues. You could take a dependency on Log4Net, Serilog or any other popular logging library. But then you have to think of a way to expose its configuration to consumers. But what if the host is hosting multiple components, all using different logging libraries? How would it manage to get all that logging to the same log file? </span></div><div style="margin: 0in;"><br /></div><div style="margin: 0in;"><span style="font-family: inherit;">This is where <a href="https://github.com/damianh/LibLog">LibLog</a> by Damian Hickey comes into play. It's a sophisticated little NuGet package that just adds a single source file (so no public dependencies!) and auto-detects the logging library loaded in the AppDomain at run-time. It supports <a href="http://nlog-project.org/">NLog</a>, <a href="https://logging.apache.org/log4net/">Log4Net</a>, Enterprise Library, <a href="http://serilog.net/">Serilog</a> and Loupe. So from inside your component, you just use the logging API provided by LibLog. As long as the host uses one of the supported libraries, your logging statements will automatically forwarded. Personally, I prefer the structured logging magic provided by Serilog.</span></div><div style="margin: 0in;"><br /></div><div style="margin: 0in;"><span style="font-weight: bold;"><span style="font-family: inherit;">Spice 5: Dependency injection without dependencies</span></span></div><div style="margin: 0in;"><span style="font-family: inherit;">Just like you don't want to have an extra dependency for that logging library, you don’t want to expose your prefered dependency injection container to leak into your public API. Fortunately, my favorite DI container <a href="http://autofac.org/">Autofac</a>does not rely on any static state and can be used within your container perfectly fine. However, we've observed lots of problems internalizing Autofac within your main assembly with both <a href="https://github.com/gluck/il-repack">ILRepack</a>as well as <a href="http://research.microsoft.com/en-us/people/mbarnett/ilmerge.aspx">ILMerge</a>. So if you can live with a thinner feature set, I can highly recommend <a href="https://github.com/grumpydev/TinyIoC">TinyIoc</a>. Just like LibLog, its NuGet package will just add a single source file to your solution, which means no dependencies, nada, niente. </span></div><div style="margin: 0in;"><br /></div><br /><div style="margin: 0in;"><span style="font-family: inherit;">Well, that's all folks. After seven posts I think I've completed my recipe for building professional middleware components. What do you think? Does this all make sense? Comment below or tweet me at <a href="https://www.twitter.com/ddoomen">@ddoomen</a>.</span></div>