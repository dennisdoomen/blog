---

title: False positives and semantic versioning
date: '2015-06-24T14:11:00.001+02:00'

tags:
- Fluent Assertions
- versioning
- semantic versioning
modified_time: '2015-06-24T14:11:53.151+02:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-6505419454779969363
blogger_orig_url: http://www.continuousimprover.com/2015/06/false-positives-and-semantic-versioning.html
---

<p>As part of stabilizing an upcoming release, I always dog food a beta package against the 12000 unit tests in one of our bigger projects. In the early days, that would surface all kinds of edge cases I never thought of. In every single case, the first thing I would do is to add a new unit test to <a href="http://www.fluentassertions.com/">Fluent Assertions</a> to make sure that edge case would be covered from that point on. But during the last couple of releases, finding a failing unit test would be pretty unique. What an unpleasant surprise it was when I encountered about 150 failing unit tests when running against a beta of <a href="https://github.com/dennisdoomen/fluentassertions/releases/tag/3.4.0">v3.4</a>. <p><img style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; border-left: 0px; display: block; padding-right: 0px; margin-right: auto" border="0" src="http://blog.myesr.org/wp_live_esr11_23zcq/wp-content/uploads/2014/03/p9_Sunday_SF15b_Figure-1-cartoon-FP.jpg" width="640" height="452"> <p>The cause of this was FA's most powerful extension method <a href="https://github.com/dennisdoomen/fluentassertions/wiki#object-graph-comparison">ShouldBeEquivalentTo</a>. It performs a recursive comparison of two object graphs. To determine which properties have to be included in the comparison, by default it's supposed to use the compile-time type (a.k.a. the declared type) of the objects in the graph. However, in early releases this didn't behave entirely consistent. Both me and top contributor <a href="https://github.com/vossad01">Adam Voss</a> have worked on the internals many times thereby slowly improving the consistency with every release. In v3.4 we both applied some more improvements, but those unfortunately surfaced a false-positive from an earlier release.  <p>In our particular case, we were comparing a collection of events, declared as <font face="Consolas">Event</font>, with another collection. Because of that existing bug (I'm not sure when it was introduced), it would still use the run-time type of the particular event during the comparison. The call to <font face="Consolas">ShouldBeEquivalentTo</font> excluded the properties of the <font face="Consolas">Event</font> base-class. And since v3.4 will now include the properties defined by <font face="Consolas">Event</font> class only, the net result is the following <font face="Consolas">InvalidOperationException</font>: <blockquote> <p><font face="Consolas">No members were found for comparison. Please specify some members to include in the comparison or choose a more meaningful assertion.</font></p></blockquote> <p>This particular exception can be solved by using the <font face="Consolas">IncludingAllRuntimeProperties</font> option. But be prepared for unit tests that suddenly fail on some nested property's value that didn't match the expectation. In all cases where this happened in our code base, the unit test failed correctly. In other words, we had some pretty serious false positives.  <p>So what does this have to do with <a href="http://semver.org/">semantic versioning</a>? Well, Fluent Assertions' release strategy is based on semantic versioning. This requires me to carefully think about the version number increment and how that affects the changes I make in a particular release. To elaborate on that a bit, assume the current version is v3.4.0. If I change some internal logic without affecting the public API and/or fix a bug in a backwards compatible fashion, I'm supposed to increment the version to v3.4.1. If instead, I'm adding new extension methods, additional overloads or marking APIs obsolete, the version should get bumped to v3.5. And finally, if I would drop those obsolete APIs or a particular .NET framework variant, I must change the version to 4.0. In short, the versioning strategy is not based on a marketing decision, but purely derived from the changes you made. By strictly adhering to this, people using v3.3 should be able to upgrade to any other v3.x version with confidence. <p>So looking back at this false-positive, the question remains whether this release demands a major, minor or patch increment. Since this release also includes new backwards-compatible API changes, it's going to be at least a minor increment. Treating it as a patch release is out of the question. However, when somebody updates their FA version from v3.3 to v3.4, chances are that it'll break some unit tests. You could say that is a breaking change they want to postpone to a later point in time. On the other hand, we're talking about a false positive here. I guess people would like to know that their production code contains a problem not previously covered by Fluent Assertions. Having said that, I've decided to treat this fix as a normal bug fix.  <p>Considering this story, I can imagine more gray area exist in the semantic versioning realm. I couldn't find a nice spot to discuss those topics, not on Gitter nor on Jabber. So until somebody else comes up with a better place, I've created a <a href="https://gitter.im/dennisdoomen/semanticversioning">Gitter room</a>. Please <a href="https://gitter.im/dennisdoomen/semanticversioning">join me here</a> if you have questions about semantic versioning.</p>  