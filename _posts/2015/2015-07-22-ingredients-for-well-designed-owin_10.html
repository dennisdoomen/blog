---

title: Ingredients for well-designed OWIN middleware components - Part 5
date: '2015-07-22T20:58:00.001+02:00'

tags:
- OWIN Recipes
modified_time: '2015-10-09T10:08:48.179+02:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-5307125618667489194
blogger_orig_url: http://www.continuousimprover.com/2015/07/ingredients-for-well-designed-owin_10.html
---

<div lang="en-US" style="margin: 0in;"><span style="font-family: inherit;">In the <a href="http://www.continuousimprover.com/2015/07/ingredients-for-well-designed-owin_22.html">fourth installment</a> of this series I proposed a pattern for postponing expensive operations from inside your middleware component until the OWIN pipeline has been constructed. In this post, I'm going to talk about aligning package dependency versions. Why? Well, in my experience a well-designed middleware component may end up resulting in more than a single NuGet package.&nbsp;</span></div><div lang="en-US" style="margin: 0in;"><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;"><b>Ingredient 6: Automatic package version alignment</b></span></div><div lang="en-US" style="margin: 0in;"><span style="font-family: inherit;">I'm not talking about its public dependencies (which you've <a href="http://www.continuousimprover.com/2015/07/recipes-for-well-designed-owin.html">obviously internalized</a>), but about other output from the same solution. For instance, imagine your middleware component supports extension points or external services in the form of an </span><span style="font-family: Courier New, Courier, monospace;">IPlugin</span><span style="font-family: inherit;"> or </span><span style="font-family: Courier New, Courier, monospace;">IWhateverDependency</span><span style="font-family: inherit;"> that you can pass through your component's settings:</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">public class MyPlugin : IPlugin<br />{<br />}</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">appBuilder.UsePiercer(new PiercerSettings().Using(new MyPlugin());</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: inherit;">Now, you could include the contract of those extensions, the </span><span style="font-family: Courier New, Courier, monospace;">IExtension</span><span style="font-family: inherit;"> interface, as part of the NuGet package that brings in the middleware component. But as an extension developer, that would require you to directly reference the middleware component. If you carefully design your component, I would put that extension interface in a dedicated NuGet package post-fixed with </span><span style="font-family: Courier New, Courier, monospace;">Extensions</span><span style="font-family: inherit;"> or something alike. </span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: inherit;">Assuming you use automatic versioning through <a href="https://github.com/GitTools/GitVersion">GitVersion</a> like I did <a href="https://github.com/dennisdoomen/piercer/blob/master/Build/default.ps1#L39">in Piercer</a>, you then have the problem of NuGet dependencies to solve. Since your middleware needs to take an implementation of the extension interface, it needs a dependency on the NuGet package that exposes the dependency. In Piercer I already demonstrated how to automatically version the assemblies using GitVersion, but that doesn't adopt the versions of the extensions package in the </span><span style="font-family: Courier New, Courier, monospace;">.nupec</span><span style="font-family: inherit;"> of the middleware package. As I assume you don't want to update the </span><span style="font-family: Courier New, Courier, monospace;">.nuspec</span><span style="font-family: inherit;"> manually, I wrote a little <a href="http://www.continuousimprover.com/2015/03/bringing-power-of-powershell-to-your.html">PSake</a>task you can use in your <a href="https://github.com/dennisdoomen/piercer/blob/master/Build/default.ps1">build script</a>.</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">task ConsolidateNuspecDeps {</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace; font-size: x-small;">&nbsp; Write-Host "Updating all NuGet dependencies on $NuGetPackageBaseName.* to version ""$NuGetVersion""" {</span></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">&nbsp;&nbsp;&nbsp; Get-ChildItem $SrcDir -Recurse -Include *.nuspec | % {</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $nuspecFile = $_.fullName;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Write-Host "&nbsp;&nbsp;&nbsp; $nuspecFile updated"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $tmpFile = $nuspecFile + ".tmp"<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Get-Content $nuspecFile | `<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; %{$_ -replace "(<dependency .="" id="" s="" ugetpackagebasename.="" version="">", "`${1} version=""$NuGetVersion""/&gt;" } | `<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Out-File -Encoding UTF8 $tmpFile </dependency></span></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Move-Item $tmpFile $nuspecFile -force<br />&nbsp;&nbsp; }<br />}</span></div><div lang="en-US" style="margin: 0in;"><br /></div><br /><div lang="en-US" style="margin: 0in;"><span style="font-family: inherit;">It will take two Powershell variables; </span><span style="font-family: Courier New, Courier, monospace;">$NuGetPackageBaseName</span><span style="font-family: inherit;"> to identity the items from the .nuspec's </span><span style="font-family: Courier New, Courier, monospace;"><dependencies></dependencies></span><span style="font-family: inherit;"> element that are part of the same set, and the </span><span style="font-family: Courier New, Courier, monospace;">$NuGetVersion</span><span style="font-family: inherit;"> to use for the final version. Notice that if you don't want to use specific versions, you're free to use a <a href="http://docs.nuget.org/create/versioning">range</a> like </span><span style="font-family: Courier New, Courier, monospace;">[1.0, 2.0)</span><span style="font-family: inherit;">instead.&nbsp;</span></div>