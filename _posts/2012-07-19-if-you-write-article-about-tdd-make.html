---

title: If you write an article about TDD, make sure it is correct
date: '2012-07-19T21:48:00.001+02:00'

tags:
- dotnetmag
- Architecture
- Testing
modified_time: '2012-07-21T09:23:34.233+02:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-1309246870639584421
blogger_orig_url: http://www.continuousimprover.com/2012/07/if-you-write-article-about-tdd-make.html
---

<p>I spend a majority of my private time reading articles and blog posts, having discussions on <a href="https://twitter.com/ddoomen/">Twitter</a>, or engaging in conversations on conferences and community events. I'm realistic enough to understand that my opinions are not necessarily the truth, so I use those opportunities to challenge my own ideas and learn about solutions I would never think of myself.  <p><img style="float: none; margin-left: auto; display: block; margin-right: auto" src="http://blog.architexa.com/wp-content/uploads/2010/04/vilcus-plug-it-in.jpg" width="201" height="289">  <p>I recently read an article titled <a href="http://msdn.microsoft.com/en-us/magazine/jj190803.aspx">Test-Driven ASP.NET MVC</a> that, although I respect what the author is trying to convey, implies some things that I strongly believe are incorrect or are malpractices. Normally I wouldn't bother to blog about this, but because his article is published at the online <a href="http://msdn.microsoft.com/en-us/magazine/jj190796.aspx">MSDN Magazine</a>, I couldn’t resist the urge to correct some things. <br> <ul> <li> <div align="left"><strong>Thoroughly understand the MVC pattern</strong>. As Martin Fowler has clearly explained in his post on <a href="http://martinfowler.com/eaaDev/uiArchs.html">GUI patterns</a>, the view doesn't manage the presentation of models, nor does it handle interactions with the users. Both are the responsibility of the controllers. They react to keyboard, mouse (and touch) input, use that information to interact with the (domain) model and then decide what view should be used to render the result. In that sense, ASP.NET MVC is reasonably faithful to the original pattern. The only big difference is that in the original MVC pattern, the controllers were directly handling user input whereas in ASP.NET MVC the controllers merely handle HTTP POSTs, GETs and PUTs. <br></div> <li><strong>Tiers are not layers</strong>. Tiers are used to represent a physical separation whereas layers represent a logical separation. You can have all layers (e.g. presentation, service, domain and data access) hosted on a single tier if you want, or you can assign them to multiple tiers. An example of that is an ASP.NET web site (the presentation layer) hosted on a front-end web server, the service, domain and data access layers hosted on a Intranet application server, and the database hosted on a dedicated database server. The other way around doesn't work like that though. If you didn't account for layering in your architecture, it might be very difficult to deploy your system in a distributed environment. <br></li></ul> <ul> <li><strong>Keep your Visual Studio projects to a minimum</strong>. Having many projects such as the project-per-layer suggested in the article considerably slows down compiling, but also causes the startup time of the corresponding application to increase. Loading 10 small assemblies is much slower than loading one big assembly. Jeremy D. Miller mentioned this already in this <a href="http://codebetter.com/blogs/jeremy.miller/archive/2008/10/10/183438.aspx">post</a>, but Patrick Smacchia, the author of NDepend, delivered some proof of if it <a href="http://codebetter.com/blogs/patricksmacchia/archive/2008/12/08/advices-on-partitioning-code-through-net-assemblies.aspx">here</a>. Read my original <a href="http://www.dennisdoomen.net/2010/02/how-to-split-solution-into-projects.html">post</a> for more guidance on splitting up projects.<br></li></ul> <ul> <li><strong>Separate test code from production code</strong>. The author recommends separating test code from production code, a good thing obviously. In fact, I would not even dare to think of polluting the production code base with test code. It might double the size of the assemblies and considerably increase the memory footprint of the application. But as usual, it is not always possible to avoid this. We sometimes have to make a method internal and allow the test projects to access those members using an [InternalsVisibleTo] assembly-level attribute. But that's an exception. What we do more often is make certain methods protected so that we can apply the <a href="http://xunitpatterns.com/Test-Specific%20Subclass.html">Test-Specific Subclass</a> pattern. <br></li></ul> <ul> <li><strong>TDD is about test-first development</strong>. The article refers to the Test-Driven Development practice a few times but never explains its essential concepts such as writing tests before writing the production code, the red-green-refactor mantra and the many benefits it offers from a design and maintenance perspective. And neither does it explain what the exact meaning of a unit in unit testing is. In fact, not a single code example shows what a unit test would look like when practicing TDD in an ASP.NET MVC application. Why then call the article Test-Driven ASP.NET MVC. This is even more surprising considering that the author is using <a href="http://codebetter.com/jeremymiller/">Jeremy D. Miller</a>'s StructureMap, somebody who has been one of the most noticeable TDD advocates in the community. I wonder whether the author really understands TDD at all. <br> <li><strong>Use Fakes with caution</strong>. This is also amplified by his apparent nonchalant use of Visual Studio 2012's <a href="http://www.slideshare.net/gaines/testing-the-untestable-with-visual-studio-2011-fakes">support</a> for generating fakes from any class. If you're practicing TDD, you’ll explicitly design the interface of your API or type and think about its dependencies. IMHO, this is an essential part of the thought process involved in TDD. Using a brute-force tool like Fakes or TypeMock Isolator allows you to ignore that part of the process and just generate whatever is needed for your test. I'm not saying Fakes or TypeMock are bad products, but because of their unique capabilities compared to popular mocking frameworks like Moq, Nsubstitue or my own favorite, <a href="https://github.com/FakeItEasy/FakeItEasy/">FakeItEasy</a>, I'm afraid many people will follow the author's example. <br> <li><strong>Dependency injection is not the same as the inversion of control principle</strong>. I hate it when developers use the terms Dependency Injection and Inversion-of-Control interchangeably. They are two different things and if you don't understand that, make sure you thoroughly read the chapter on the Dependency Inversion Principle in <a href="http://lostechies.com/wp-content/uploads/2011/03/pablos_solid_ebook.pdf">Pablo's SOLID guidelines</a>. Although subtlety different, Inversion-of-control is essentially about removing the direct dependencies of one class to another out of that class and providing an abstraction that that class relies on. The inversion in this principle is about moving the responsibility for hooking up the original class with a concrete implementation of that abstraction to a 3rd party, typically an IoC framework. This will improve your chances for loose coupling, better testability, and increased maintainability on the long run. Obviously you don't have to use a DI framework, but if you do it correctly you can gain a lot of benefits from it. I myself heavily rely on Autofac after having used Microsoft Unity <a href="http://www.dennisdoomen.net/2011/09/silverlight-cookbook-switching-to.html">for a few years</a>. And remember, just like any principle or tool, use it with caution. Overusing IoC can result in systems were it is difficult to understand what happens. <br> <li><strong>Resolving dependencies from inside a class completely defies the ideas behind DI</strong>. Why in the world would you suggest people to use an DI framework like StructureMap and then use a static class to resolve dependencies from within the dependent class? That vaporizes the entire purpose of a DI framework. It's not for nothing that Jeremy D. Miller wrote a post on <a href="http://codebetter.com/jeremymiller/2006/03/09/jeremys-second-law-of-tdd-push-dont-pull/">Push, Don't Pull</a>. Even better, that's why the word injection is in Dependency Injection! That is also why the author suggest registering a fake object in his IoC container. This is clearly a design smell resulting from his apparent incorrect understanding of the IoC principle. <br></li></ul> <ul> <li><strong>One more issue</strong>. In the discussion on namespaces and test code, the author suggested to use the name Test (singular) in the project name. Since the namespaces in projects should use the project name as their base, you end-up with the name of something that could be the name of a class. That has been a violation of the Microsoft Design Guidelines and FxCop naming rules since the inception of the .NET Framework. I usually use the name Tests, Testing or Specs for the project that holds the unit and integration tests. </li></ul> <p>Anyway, the morale of this post is that you should get your facts straight before you write an article that is going to reach so many people. And now that I think of it, why didn't somebody from the MSDN Magazine's staff check this article in the first place? I might be wrong as well, so if disagree let me know by commenting on this post or by pinging me through my twitter handle at <a href="https://twitter.com/ddoomen/">ddoomen</a>.</p>  