---

title: Fluent Assertions 1.2 has been released
date: '2010-04-12T13:17:00.001+02:00'

tags:
- Visual Studio
- ALM
- dotnetmag
- Quality
- Testing
modified_time: '2010-04-12T13:25:11.541+02:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-8311982362194724250
blogger_orig_url: http://www.continuousimprover.com/2010/04/fluent-assertions-12-has-been-released.html
---

<p>It has been only <a href="http://www.dennisdoomen.net/2010/03/fluent-assertions-released-on-codeplex.html">6 weeks</a> since I first released Fluent Assertions to the public, followed by <a href="http://www.dennisdoomen.net/2010/03/fluent-assertions-11-has-been-released.html">version 1.1</a> a week later. In the weeks thereafter, I received some nice ideas from the community which caused me to start working on the next version.</p>  <p>But it was not easy. I found that designing a small framework like this really requires you to carefully design the syntax you want to offer. For instance, I underestimated the <a href="http://www.dennisdoomen.net/2010/03/curious-case-of-unsolved-extension.html">limits</a> of the current version of C# and had to make some tough decisions along the way. But I'm done now, so get <a href="http://fluentassertions.codeplex.com/releases/view/41995">version 1.2</a> from <a href="http://fluentassertions.codeplex.com/">CodePlex</a>. However, please read this post before you start introducing it in your project. Those tough decisions will cause some minor inconvenience.</p>  <h4>New collection assertions</h4>  <p>The collection assertion methods now include a <font face="Consolas">BeNull()</font> and <font face="Consolas">NotBeNull()</font> to ensure that a collection is initialized or not. I’ve also made sure that the <font face="Consolas">Contains()</font> method of a generic collection takes an object of the right type instead of <font face="Consolas">System.Object</font> (this breaks existing usages though). And if that is not enough, you can also pass in a lambda expression to specify that the collection should contain a specific instance. Something like this:</p>  <blockquote>   <p><font face="Consolas">dtoCollection.Should().Contain(dto =&gt; dto.Id != null);</font></p> </blockquote>  <p>Similarly, you can also use a lambda when asserting the count of a collection:</p>  <blockquote>   <p><font face="Consolas">collection.Should().HaveCount(c =&gt; c &gt;= 3);</font></p> </blockquote>  <p>If the subject-under-test does not comply with the expression, it will include the actual expression of the lambda in the error message. As a matter of fact, this applies to all assertion methods that take a lambda expression.</p>  <h4>Comparing objects by their properties</h4>  <p>I’ve added the possibility to assert the equality of entire objects by comparing their properties by name. This even works if the types of the properties differ but a built-in conversion exists (through the <font face="Consolas">Convert</font> class). As an example, consider a <font face="Consolas">Customer</font> entity from some arbitrary domain model and its <a href="http://en.wikipedia.org/wiki/Data_transfer_object">DTO</a> counterpart <font face="Consolas">CustomerDto</font>. You can assert that the DTO has the same values as the entity using this syntax:</p>  <blockquote>   <p><font face="Consolas">dto.ShouldHave().AllProperties().EqualTo(customer);</font></p> </blockquote>  <p>As long as all properties of <font face="Consolas">dto</font> are also available on <font face="Consolas">customer</font>, and their value is equal or convertible, the assertion succeeds. You can, however, exclude a specific property using a lambda, such as for instance the ID property:</p>  <blockquote>   <p><font face="Consolas">dto.ShouldHave().AllPropertiesBut(d =&gt; d.Id).EqualTo(customer);</font></p> </blockquote>  <p>The other way around is also possible. So if you only want to include two specific properties, use this syntax.</p>  <blockquote>   <p><font face="Consolas">dto.ShouldHave().Properties(d =&gt; d.Name, d =&gt; d.Address).EqualTo(customer);</font></p> </blockquote>  <h4>Comparing dates and times</h4>  <p>In addition to simple assertions between two <font face="Consolas">DateTime</font> objects, I’ve added a whole bunch of methods for asserting that two dates or times differ a specific amount of time (specified using a <font face="Consolas">TimeSpan</font>). With these you can do things like:</p>  <blockquote>   <p><font face="Consolas">dt1.Should().BeWithin(TimeSpan.FromHours(50)).Before(dt2);        <br />dt2.Should().BeLessThan(TimeSpan.FromDays(1).After(dt2);</font></p> </blockquote>  <p>It supports <font face="Consolas">BeMoreThan()</font>, <font face="Consolas">BeAtLeast()</font>, <font face="Consolas">BeExactly()</font>, <font face="Consolas">BeWithin()</font> and <font face="Consolas">BeLessThan()</font> before or after a specific date and/or time.</p>  <h4>Other improvements</h4>  <p>In addition to fixing several minor bugs reported by the community, I have spend a considerable amount of time in making sure the assertion failure messages clearly explain why it failed. For instance, a date/time assertion might return the following (lengthy) exception message:</p>  <blockquote>   <p>”Expected date and/or time &lt;2010-04-08 09:59:59&gt; to be within 2d and 2h before &lt;2010-04-10 12:00:00&gt; because 50 hours is enough, but it differs 2d, 2h and 1s.”.</p> </blockquote>  <p>The part after the <em>because</em> is the part that you need to add using one of the many overloads. It really helps to keep the developer from the need to start the debugger. </p>  <p>One particular bug I fixed was when asserting that a collection of strings contained a particular string, it was interpreted as an <font face="Consolas">IEnumerable</font> of <font face="Consolas">Char</font>. Obviously it never succeeded, regardless of the fact that the original string was part of the collection.</p>  <p>I also looked at extensibility a bit more by making classes public and ensuring you can override an assertion class at the right spots. I still have to do some work here, but whenever somebody has a problem, I’ll fix it soon enough.</p>  <h4>So what did you break?</h4>  <p>As a result of some important feedback from the community, my desire to remove a lot of noise from the syntax, and limitations of the language <a href="http://www.dennisdoomen.net/2010/03/curious-case-of-unsolved-extension.html">I ran into</a>, I decided to introduce some changes that will break existing code. Fortunately, it is just a cosmetic change, so some smart search/replace should get you back on track easily.</p>  <p>First of all, I’ve renamed almost all <font face="Consolas">Equal()</font> methods to <font face="Consolas">Be()</font>. So instead of <font face="Consolas">myString.Should().Equal(“hello”)</font> you now have to write <font face="Consolas">myString.Should().Be(“hello”)</font>. The only exception to this is the one for comparing two collections for equality, since it’s purpose to see if they have the same items.</p>  <p>Also, I’ve renamed the <font face="Consolas">Satisfy()</font> method for asserting an arbitrary object against a lambda expression to <font face="Consolas">Match()</font>. Apparently, the word <em>satisfy</em> was a bit to technical. On the flipside, you now get multiple overloads which allows you to do the following. </p>  <blockquote>   <p><font face="Consolas">o.Should().Match(obj =&gt; obj == null)        <br /></font><font face="Consolas">o.Should().Match&lt;CustomerDto&gt;(d =&gt; d.Name.Length &gt; 0);        <br /></font><font face="Consolas">o.Should().Match((CustomerDto d) =&gt; d.Name.Length &gt; 0);</font></p> </blockquote>  <p>The whole exception throwing assertion syntax was way too noisy, so I removed some unnecessary parts and changed the overall syntax. For instance</p>  <blockquote>   <p><font face="Consolas">someObject.ShouldThrow(x =&gt; x.SomeMethod()).Exception&lt;SomeException&gt;();</font></p> </blockquote>  <p>has been changed into</p>  <blockquote>   <p><font face="Consolas">someObject.Invoking(x =&gt; x.SomeMethod()).ShouldThrow&lt;SomeException&gt;();</font></p> </blockquote>  <p>Which doesn’t really remove noise, but feels more natural to me when invoking a lambda expression. When using an <font face="Consolas">Action&lt;T&gt;</font>, the syntax has changed as well. Consider a class with a method <font face="Consolas">Foo()</font> that should throw an instance of <font face="Consolas">SomeException</font>:</p>  <blockquote>   <p><font face="Consolas">Action act = () =&gt; someObject.Foo();</font></p> </blockquote>  <p>In 1.1 asserting that <font face="Consolas">Foo()</font> really threw that specific exception with specific values for its <font face="Consolas">Message</font> and a custom property <font face="Consolas">SomeParam </font>had to be done like this:</p>  <blockquote>   <p><font face="Consolas">act.ShouldThrow().Exception&lt;SomeException&gt;().        <br />&#160;&#160; And.WithMessage(“Something went wrong”).         <br />&#160;&#160; And.ValueOf.SomeParam.Should().Equal(23);</font></p> </blockquote>  <p>In 1.2 I’ve changed it into:</p>  <blockquote>   <p><font face="Consolas">act.ShouldThrow&lt;SomeException&gt;().        <br />&#160;&#160; WithMessage(“Something went wrong”).         <br />&#160;&#160; And.SomeParams.Should().Equal(23);</font></p> </blockquote>  <p>You can download version 1.2 from <a href="http://fluentassertions.codeplex.com/releases/view/41995">here</a>.</p>  