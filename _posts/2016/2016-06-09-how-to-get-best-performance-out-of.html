---

title: How to get the best performance out of NHibernate (and when not to use it at
  all)
date: '2016-06-09T21:12:00.001+02:00'

tags:
- nhiberate
- performance
- caching
modified_time: '2016-06-09T21:12:38.687+02:00'
thumbnail: https://lh3.googleusercontent.com/-LoAEqf0hUOQ/V1m_o3PhZqI/AAAAAAAAKYM/7MQk_OboTf0/s72-c/clip_image001_thumb%25255B2%25255D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-15137028.post-5449161391502291518
blogger_orig_url: http://www.continuousimprover.com/2016/06/how-to-get-best-performance-out-of.html
---

<p><strong>Use the right tool for the right problem</strong> <p>A very common sentiment I'm getting from the .NET community is the aversion against object-relational mappers like NHibernate and Entity Framework. Granted, if I could, I would use an (embeddable) NoSQL solution like <a href="https://ravendb.net/">RavenDB</a> myself. They remove the object-relational friction OR/Ms try to solve and allow you to decouple your code from scalability bottlenecks like shared database servers. And quite often they provide some cool features such as map-reduce indexes and faceted search. If a NoSQL product is not an option, some would argue that writing native SQL is always the better option. But in my opinion, unless you need to squeeze out the last bit of performance from a database, writing your own SQL statements is a waste of time. But even then, I would probably prefer some lightweight mapping library such as Dapper then writing the mapping code myself<a href="https://lh3.googleusercontent.com/-4CixpXIHMl0/V1m_oOZA1RI/AAAAAAAAKYE/KwrCbopxUhQ/s1600-h/clip_image001%25255B5%25255D.png"><img title="clip_image001" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; border-left: 0px; display: block; padding-right: 0px; margin-right: auto" border="0" alt="clip_image001" src="https://lh3.googleusercontent.com/-LoAEqf0hUOQ/V1m_o3PhZqI/AAAAAAAAKYM/7MQk_OboTf0/clip_image001_thumb%25255B2%25255D.png?imgmax=800" width="640" height="278"></a>Those same people would also argue that NHibernate adds a lot of overhead and complexity, and there's some truth in there. It's a very powerful OR/M that is very good at mapping complex object-oriented designs to a relational database schema, but there's also a lot you can do wrong that will completely kill your performance. I once made the mistake of creating an abstraction on top of NHibernate (inspired by <a href="https://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=84">this article</a>). It sounded like a nice idea for testability purposes, but treating NHibernate as a persistent LINQ-enabled collection forced me to limit myself to the common denominator (a.k.a. LINQ).  <p>Regardless, if you can't use a NoSQL solution like RavenDB, you can't apply an architectural style that avoids the object-relation mismatch (e.g. <a href="http://www.slideshare.net/dennisdoomen/building-occasionally-connected-applications-using-event-sourcing">Event Sourcing and/or CQRS</a>), you need to support multiple database vendors, and you don't need the raw performance of native SQL, I would <a href="http://www.continuousimprover.com/2013/03/entity-framework-56-vs-nhibernate-3.html">still</a> recommend NHibernate over Entity Framework.  <p>Now, when you do, please don't make the mistakes I made, and apply some or all of the following tips &amp; tricks. For the record, I'm assuming you use <a href="https://github.com/jagregory/fluent-nhibernate">Fluent NHibernate</a> to avoid those ugly XML files. I never bothered with the built-in fluent API because I kind of got the impression it is still work-in-progress (hopefully somebody can convince me otherwise).  <p><strong>Don't abstract NHibernate</strong> <p>If you're practicing <a href="http://www.continuousimprover.com/2015/11/12-tips-to-write-unit-tests-that-dont.html">Test Driven Development</a>, don't abstract away the code that uses NHibernate and write unit tests against an <a href="http://stackoverflow.com/questions/11894941/sqlite-how-do-i-connect-to-an-in-memory-shared-cache-database">in-memory Sqlite</a> or <a href="https://blogs.msdn.microsoft.com/sqlexpress/2011/07/12/introducing-localdb-an-improved-sql-express/">SQL Server LocalDB</a> using NHibernate's built-in <a href="http://weblogs.asp.net/ricardoperes/lesser-known-nhibernate-features-%E2%80%93-generating-database-scripts">schema generation tool</a>. It will surface any edge cases in NHibernate's LINQ support much earlier, and you will be able to profile the underlying raw queries right from inside your unit test. Which brings me to the next point… <p><strong>Understand the run-time behavior</strong> <p><a href="https://ayende.com/">Ayende</a>'s <a href="https://www.hibernatingrhinos.com/products/nhprof">NHProf</a> is an awesome tool to find performance bottlenecks and common mistakes. It will not only show you’re the queries you've been executed, but also show you the entire stack trace of the code that was involved. Next to that, it can provide you with the actual results of that query as well as the full query execution plan from the underlying database. For each query it shows what part of the execution time was spent in the database and what part is added by NHibernate as well. It will even show you whether or not the query benefitted from NH's 2nd-level cache. And did I mention all the warnings it will give you when you're making common mistake such as N+1 selects, inefficient transaction management, or requesting unbounded result sets? In a way NHProf gives you a holistic view of your application's database interaction.  <p><a href="https://lh3.googleusercontent.com/-7FiqgtMaBqw/V1m_pJjl0uI/AAAAAAAAKYU/n4XShA6BuBM/s1600-h/clip_image002%25255B5%25255D.png"><img title="clip_image002" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; border-left: 0px; display: block; padding-right: 0px; margin-right: auto" border="0" alt="clip_image002" src="https://lh3.googleusercontent.com/-tOJ6IYHC-TQ/V1m_paejEaI/AAAAAAAAKYc/pv-k9V4_uh0/clip_image002_thumb%25255B2%25255D.png?imgmax=800" width="640" height="443"></a> <p><strong>Prefer NH's own QueryOver API over LINQ</strong> <p>LINQ is a common denominator and doesn't support everything NH supports such as e.g. inner joins, left and right out joins, aliasing, projection transformers, etc. One more reason not to abstract NHibernate… <blockquote> <p>decimal mostExpensiveProduct = session.QueryOver&lt;Product&gt;().Select(Projections.Max&lt;Product&gt;(x =&gt; x.Price)).SingleOrDefault&lt;decimal&gt;();</p></blockquote> <p><strong>Use optimistic concurrency and dynamic updates</strong> <p>NH's default behavior is to include all columns in every UPDATE or INSERT statement, regardless if the mapped property has changed or not. NH will also include all columns in the WHERE clause when doing an <a href="http://nhibernate.info/doc/nhibernate-reference/transactions.html">optimistic concurrency check</a>. You can improve the speed of the latter by adding some kind of incremental number or timestamp and map that one as the version for the entity. That ensures that only the versioning column is included in the WHERE clause. But you can do even better by enabling dynamic updates on the mapping, e.g. using the DynamicUpdate method of the ClassMap&lt;T&gt;. This will tell NH to only include the actual columns that changed in the UPDATE and INSERT statements. I don't need to explain why that will give you a nice performance boost. <blockquote> <p>public class ProductClassMap : ClassMap&lt;Product&gt;<br>{<br>&nbsp;&nbsp;&nbsp; public ProductClassMap ()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DynamicUpdate();</p> <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Id(x =&gt; x.ProductId);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Version(x =&gt; x.Version);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Map(x =&gt; x.Name);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Map(x =&gt; x.Price);<br>&nbsp;&nbsp;&nbsp; }<br>}<br></p> </blockquote> <p><strong>Avoiding the insert-insert-update for child collections</strong> <p>A long-standing issue that has caused a lot of confusion in many of my projects is the way NH deals with parent-child relationships (also known as HasMany associations). For reasons related to <a href="http://bchavez.bitarmory.com/archive/2007/10/06/nhibernate-and-inversetruefalse-attribute.aspx">association ownership</a>, NH will first insert the children without any foreign key, and then issue another update of those children after the parent has been added. Because of this weird algorithm, the foreign key column on the child table has to be nullable. Because of all of this, inserting a new parent with 5 childs involves a total of 11 SQL statements. 5 to insert the children, one to insert the parent and another 5 to update the foreign keys of those children. I only recently discovered that this has been changed in NHibernate 3.2 and you can now fix this by using the following (fluent) construct. <blockquote> <p>public class OrderClassMap : ClassMap&lt;Order&gt;<br>{<br>&nbsp;&nbsp;&nbsp; public OrderClassMap ()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HasMany(x =&gt; x.Products)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Not.Inverse()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Not.KeyNullable()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Not.KeyUpdate()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Cascade.AllDeleteOrphan();<br>&nbsp;&nbsp;&nbsp; }<br>}<br></p></blockquote> <p> <p>Notice the Not.KeyNullable() and Not.KeyUpdate(). You need both to make this work. The additional Not.Inverse() is not really needed, but can be used to emphasize that the Order in this association is responsible for maintaining the foreign key relationships. In NH jargon, this means that this side owns the association. You only need the Inverse() option in bi-directional associations so that NHibernate knows whether the Parent or the Child is responsible for properly setting up foreign keys. If this inverse thing still confuses you, I can highly recommend <a href="http://notherdev.blogspot.nl/2012/04/nhibernates-inverse-what-does-it-really.html">this article</a>.  <p><strong>Lazy-loading heavy loaded properties</strong></p> <p>Sometimes you need to map a property on your entity that is pretty expensive to load and save, e.g. a byte array or some serialized Json or Xml. I know, you may want to avoid that in the first place, but if you can't, you need to know that you can mark <a href="https://ayende.com/blog/4377/nhibernate-new-feature-lazy-properties">properties as lazy loading</a> like this:</p> <blockquote> <p>Map(x =&gt; x.Thumbnail).LazyLoad();</p></blockquote> <p>So, assuming the ProductClassMap from earlier examples, when you fetch one or more orders, it will exclude the thumbnail data from the SELECT statement. But as soon as you access that property, it will issue a separate SELECT to get the actual column data. One caveat though. If you have multiple lazy-loaded properties, NH will fetch all them as soon as you access any of them. </p> <p><strong>Eager fetching of associations</strong> <p>Associations between entities are never initialized by default. This is well-known source of the infamous N+1 SELECT problem that happens when you load a bunch of entities using a query and then iterate over them. The first SELECT will get the parent entities, but accessing the association property of each parent entity will cause another SELECT to fetch the related childs. You can tell NH to fetch those children as part of a query using @ on a case by case. But if you know you'll always need them together and you can't merge those two tables in a nice and eficient cartesion product, map the association as a Not.LazyLoad().Fetch.Join(). <p><strong>Components without value semantics</strong> <p>A very much misunderstood aspect of <a href="https://github.com/jagregory/fluent-nhibernate/wiki/Fluent-mapping#components">component mapping</a> is that the classes that are mapped as a component must behave like a component. They must expose value type semantics and have no identity other than the combined values of all of its properties. In other words, they must override Equals() and GetHashCode(). This is especially important when you map a property to a collection of components, like this: <blockquote> <p>HasMany&lt;Address&gt;(x =&gt; x.Shipments)<br>&nbsp;&nbsp;&nbsp; .KeyColumn("OrderId")<br>&nbsp;&nbsp;&nbsp; .Table("OrderShipments")<br>&nbsp;&nbsp;&nbsp; .Component(x =&gt;<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x.Map(c =&gt; c.ZipCode);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x.Map(c =&gt; c.Number);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x.Map(c =&gt; c.State);<br>&nbsp;&nbsp;&nbsp; })<br>&nbsp;&nbsp;&nbsp; .Cascade.AllDeleteOrphan();<br></p></blockquote> <p>If you don't, NH can't determine the equality of the objects in your collection property resulting in some weird behavior. I’ve seen NH delete and insert the same set of child objects every time somebody added an additional child to the collection. You don't notice that until you run that profiler again.  <p><strong>Some more tips &amp; tricks</strong> <ul> <li>If you're in a position that you can't change too much of an existing database scheme, and you're application has vastly different needs in the way that data is read or written, you can consider multiple ClassMap to the same table. As long as all but one class maps are declared as ReadOnly, Nhibernate wil happily allow you. This has proved to be a very efficient technique to have different lazy-loading settings for the same table structure. </li> <li>If you're into Domain Driven Design like me, you might be tempted to create all kinds of domain-specific and rich <a href="https://dzone.com/articles/understanding-nhibernate-type">custom NHibernate types</a> and map them to your columns. So rather than having a string-valued property to represent an ISBN number, you might define your own Isbn type. Now, if you value performance, don't. Just run a good CPU profiler like JetBrains' <a href="https://www.jetbrains.com/profiler/">dotTrace</a> to understand the impact of that. </li> <li>Don't underestimate the power of NHibernate's <a href="https://ayende.com/blog/3976/nhibernate-2nd-level-cache">second level cache</a> offered by the likes of SysCache2. It can give you an enormous performance boost, especially if you deal with a lot of immutable data and you can avoid the infrastructural complexity of a distributed cache. Just don't forget to wrap all your code with a call to EnlistTransaction and CompleteTransaction. Ayende has written <a href="https://ayende.com/blog/3112/nhibernate-and-the-second-level-cache-tips">enough</a> about that.</li> <li>Consider you need to remove an entire range of entities from your database. You could query for them using LINQ or QueryOver and then issue individual Delete() statements on the session, but you can do better by employing NH's DML operations API. It supports HQL statements that resemble native SQL without any coupling to a specific database vendor like this:<br><br>session.CreateQuery("delete Order order where order.CreatedAt &gt; :minData")<br>&nbsp;&nbsp;&nbsp; .SetDateTime(minData).ExecuteUpdate();</li> <li>You might know that you need to define cascading operations on parent-child collections. Just don't make the mistake to do this on HasManyToMany or References mappings. They are meant to create associations between entities which lifetime is indepednent of other entities. Doing it wrong caught us by surprise a couple of times, only to discover somebody added a Cascade.All or Cascade.AllDeleteOrphan(). </li> <li>NHibernate allows you to map simple collections of single elements such as numbers or strings to a child collection. But if you do, think hard about the uniqueness of those elements. By default, NH will treat an IList or array as a bag and allow duplicate items. If you don't want that, add an AsSet to the mapping like this:</li> <li>HasMany(x =&gt; x.Options).Table("Options").KeyColumn("ParentId").Element("OptionValue").AsSet();</li></ul> <p>Well, that got a bit out of hand. What do you think? Did I tell you something you didn't know yet? And what about you? Any tips to add to this post? Love to hear your thoughts by commenting below. And follow me at <a href="https://twitter.com/ddoomen">@ddoomen</a> to get regular updates on my everlasting quest for better solutions.</p>