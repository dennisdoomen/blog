---

title: Evaluating RavenDB as an embedded database
date: '2016-01-05T21:11:00.001+01:00'

tags: 
modified_time: '2016-01-06T07:48:19.829+01:00'
thumbnail: https://lh3.googleusercontent.com/-oD9w4x-0hEI/VowjZxh3yXI/AAAAAAAAKVw/pPuIvzxCVcc/s72-c/clip_image001%25255B4%25255D_thumb%25255B2%25255D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-15137028.post-8070317551760900493
blogger_orig_url: http://www.continuousimprover.com/2016/01/evaluating-ravendb-as-embedded-database.html
---

<p>During the last two months of 2015, we've been evaluating RavenDB 3.0.30000 as an embedded database hosted in a Windows Service. We employ an architecture based on Command Query Responsibility Segregation and Event Sourcing architectural styles, but this post is relevant to anybody who wants to use RavenDB in embedded scenarios.  <p><strong>What we intended to achieve<br></strong>This is a high-level diagram of our architecture:  <p><a href="https://lh3.googleusercontent.com/-qjxEIWv0WZY/VowjZWanlKI/AAAAAAAAKVs/RuJpagwKPkA/s1600-h/clip_image001%25255B4%25255D%25255B4%25255D.png"><img title="clip_image001[4]" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; display: block; padding-right: 0px; border-top-width: 0px; margin-right: auto" border="0" alt="clip_image001[4]" src="https://lh3.googleusercontent.com/-oD9w4x-0hEI/VowjZxh3yXI/AAAAAAAAKVw/pPuIvzxCVcc/clip_image001%25255B4%25255D_thumb%25255B2%25255D.png?imgmax=800" width="640" height="416"></a>  <p>In this architecture, you can identify two clearly separated sides. The right side (or write side) deals with the business commands and the logic that determines the effect on the domain. The left side (or read side) handles query requests and is tasked with answering those queries as efficient as possible. The only communication between those sides involves the exchange of business events that are raised by the domain as a result of executing commands. Those events represent functional changes in the domain such as a <font face="Courier New">ProductDiscontinuedEvent</font> or a <font face="Courier New">PermitSignedEvent</font>. The so-called projectors are there to project those functional events into a (denormalized) form that can be easily consumed by the code that needs to answer the queries.  <p>Before the evaluation, those projections were persisted as simple tables in an RDBMS such as SQL Server, Oracle or lighter variants such as SQL Compact or SQLite. Although we initially projected the events within the same HTTP request that caused the business command to be executed. But the read side doesn't necessarily need to be updated in real-time. In fact, by making the projection process completely asynchronous, you can trade-off the consistency of the query store and gain higher performance instead. You can do that using a dedicated process or, like us, using a background thread hosted within the ASP.NET process.  <p><strong>The spike</strong><br>Unfortunately that introduces an additional challenge when multiple instances of this ASP.NET process are run in a load-balanced web farm. In that case, you need to figure out which of the ASP.NET processes is going to handle the asynchronous projection work. You don't want all of them to compete for the same database resourcing, so some kind of synchronization protocol would be needed. Instead, we've been spiking a scenario in which an embedded instance of RavenDB is used as the query store at the left side of the diagram. With that, we hoped to benefit from the following (potential) RavenDB USPs.  <ul> <li>Schema-less projections. Just write an object graph to the store, even if the structure has changed.  <li>A very low deployment footprint because the binaries can be shipped with the product.  <li>The ability to use a local per-application-server database rather than a shared networked RDBMS.  <li>High-performance, asynchronous indexing with advanced features like map-reduce, hierarchical indexes and facet-based queries using Lucene.  <li>Excellent operational dashboard with built-in profiling features</li></ul> <p>In the spike, we created a little console application that hosts RavenDB in embedded mode and uses <a href="https://github.com/NEventStore/NEventStore">NEventStore</a> to read the events from a SQL Server database. Those events are then projected to a relatively complex object that is loaded and stored to and from the local RavenDB database, using a single RavenDB session per functional transaction (a group of events that were raised within the same <a href="https://github.com/NEventStore/NEventStore/wiki/Transactional-Integrity">functional transaction</a>).  <p><strong>Challenges</strong><br>RavenDB supports two different storage engines, <a href="https://en.wikipedia.org/wiki/Extensible_Storage_Engine">Esent</a>, which is Windows' internal database, and <a href="https://ayende.com/blog/168322/what-is-new-in-ravendb-3-0-voron">Voron</a>, a proprietary engine build specifically by <a href="https://ayende.com/blog">Oren Eini</a> (the brains behind RavenDB) to be able to optimize it for RavenDB. It took us quite some time on the <a href="https://groups.google.com/forum/#!forum/ravendb">RavenDB discussion</a> forums to get a definitive answer on which one is best suited for our purpose. Most people recommended Esent, both for its write speed and its memory consumption, which brings me to the next point.&nbsp; <p>While testing with various production databases, we noticed exceptional high memory usage. On my machine, which has 16GB, it was not unusual to see the process' memory footprint to exceed 10GB. Since RavenDB is designed to take as much memory as possible to be fast, this is kind of expected behavior. But since we intend to host it in a little Windows Service that runs alongside IIS on each application server, being able to control the memory is crucial. With the help of Oren, we managed to get the right settings in place to get some more grip on memory usage. With Voron, we never managed to get memory usage under 3GB, but we were much more successful with Esent.  <p><font face="Courier New">var documentStore = new EmbeddableDocumentStore<br>{<br>&nbsp;&nbsp;&nbsp; Conventions =<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MaxNumberOfRequestsPerSession = 100,<br>&nbsp;&nbsp;&nbsp; },<br>&nbsp;&nbsp;&nbsp; Configuration =<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DefaultStorageTypeName = "Esent",<br>&nbsp;&nbsp;&nbsp; },<br>};</font></p> <p><font face="Courier New">var configuration = documentStore.Configuration;<br>configuration.Settings.Add("Raven/Esent/CacheSizeMax", "256");<br>configuration.Settings.Add("Raven/Esent/MaxVerPages", "32");<br>configuration.Settings.Add("Raven/MemoryCacheLimitMegabytes", "512");<br>configuration.Settings.Add("Raven/MaxNumberOfItemsToIndexInSingleBatch", "4096");<br>configuration.Settings.Add("Raven/MaxNumberOfItemsToPreFetchForIndexing", "4096");<br>configuration.Settings.Add("Raven/InitialNumberOfItemsToIndexInSingleBatch", "64");</p></font> <p>Large portions of the existing projection class hierarchy from the production code base wasn't JSON serializable, so we had to jump through quite a few hoops to get it to work nicely with RavenDB. In particular, our overzealous usage of value objects on projections proved to be a pain. In fact, at some point, we managed to completely kill RavenDB with a single 200MB document caused by a bug in our serialization code. We had to send memory dumps to Oren's team to learn how to diagnose these kinds of problems. Definitely something to remember while taking the next steps.  <p><strong>Performance Results<br></strong>As a benchmark we used a production database that we used during a prior performance analysis of SQL Server. It contains 1.6 million events (grouped in 412000 functional transactions). Rebuilding the projections (and its associated lookup tables) through the production code-base using SQL Server on my local HDD took 0h23m. However, in production, the SQL Server instance and the application server are different machines. So rerunning that test against a networked SQL Server (with a latency of 1ms), resulted in a total time of 1h22m. Doing the same test using RavenDB using the Esent engine on an SSD took 0h46m. Switching to my HDD didn't make too much of a difference though (+2 minutes), but I can't really explain that.  <p>However, we were quite disappointed with the performance. We knew our projection wasn't particularly optimized for JSON serialization, but we expected a bit more. After doing some performance and memory analysis with the <a href="https://www.jetbrains.com/profiler/">JetBrains tools</a>, we concluded that a majority of the time is spend in RavenDB. We also participated in several discussions on Google Groups to get a better understanding on this. RavenDB has two features that we suspected could help, <a href="http://ravendb.net/docs/article-page/3.0/csharp/client-api/how-to/setup-aggressive-caching">Aggressive Caching</a> and the <a href="http://ravendb.net/docs/article-page/3.0/csharp/client-api/commands/patches/how-to-work-with-patch-requests">Patching API</a>, but neither appeared to be meant to be used in embedded scenarios.  <p>So the next thing we tried is to introduce a <a href="https://github.com/dennisdoomen/fluidcaching">Least Recently Used</a> cache to prevent too many unnecessary loads when several closely located functional transactions affect the same projection. This dropped the rebuild time to 0h34m. Not that spectacular, but a similar run using the a much larger production database (14 million events), caused the test run to drop from 5h50 to 4h35.  <p>The last thing we tried is to process the functional transactions in batches of 10, thereby extending the lifetime of the <a href="http://ravendb.net/docs/article-page/3.0/csharp/client-api/session/what-is-a-session-and-how-does-it-work">RavenDB session</a> a bit. RavenDB is designed for short-lived sessions and uses all kinds of <a href="http://ayende.com/blog/4814/ravendb-safe-by-default-design-it-works">safe-by-defaults</a>, but we already extended those limitations a bit. After we did that, the rebuild time for both databases dropped to respectively 0h21m and 3h07m. That's definitely good enough for the spike.  <p><strong>Conclusions</strong>  <ul> <li>Esent is still the engine of your choice, especially now that we managed to control the memory consumption.  <li>Don't bother with the Patching API in an embedded scenario. It won't give you any benefits, although Oren mentioned that he's working on some improvements for RavenDB 4.x.  <li>Use only primitive types on the projections. This prevents unnecessary (de)serialization.  <li>Don't map a hierarchy of sub-classes to a single document. Store them as separate documents so that individual documents stay small and focused. Use <a href="https://ravendb.net/docs/article-page/3.0/csharp/indexes/indexing-hierarchical-data">hierarchical indexes</a> to query over the class hierarchies.  <li>Consider splitting big collections within your object to serialize into separate documents, and use the <a href="https://ravendb.net/docs/article-page/3.0/csharp/indexes/querying/handling-document-relationships">Include</a> feature were needed.  <li>The operational dashboard (<a href="https://ravendb.net/docs/article-page/3.0/csharp/studio/accessing-studio">Raven Management Studio</a>) is exceptionally good for tracing and diagnosing what's going on.</li></ul> <p>All in all, we are very confident that this is the way to go for scenarios like discussed above. So what do you think? Are you considering RavenDB yourself? And if you're already using it, I'd love to hear about your experiences with RavenDB. Just let me know by commenting below. Oh, and follow me at <a href="https://twitter.com/ddoomen">@ddoomen</a> to get regular updates on my everlasting quest for better solutions. </p>