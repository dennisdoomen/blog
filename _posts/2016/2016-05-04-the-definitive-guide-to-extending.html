---

title: The definitive guide to extending Fluent Assertions
date: '2016-05-04T17:13:00.001+02:00'

tags:
- Fluent Assertions
modified_time: '2016-05-04T17:13:34.356+02:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-1166274817455327162
blogger_orig_url: http://www.continuousimprover.com/2016/05/the-definitive-guide-to-extending.html
---

<p><strong>Some background </strong> <p>In my recent post about the responsibilities of an open-source developer <a href="http://www.continuousimprover.com/2016/04/why-software-innovation-is-not-free.html">I said</a> that the author of an open-source project is fully entitled to reject a contribution. In the case of Fluent Assertions, this is no different. Some things just aren't a good fit for a general purpose assertion library, especially if that feature is tied to a specific type of technology. Some things are a good fit though. The <a href="https://github.com/dennisdoomen/FluentAssertions/pull/391">upcoming</a> support for JSon is one example of that. It started as a separate NuGet package, but is about to get merged into the core package.  <p>To facilitate the need for those developers which ideas don't end up in the library, FA offers several extension points. They are there so that they can build their own extensions with the same consistent API and behavior people are used to. And if they feel the need to alter the behavior of the built-in set of assertion methods, they can use the many hooks offered out of the box. The flipside of all of this is that we cannot just change the internals of FA without considering backwards compatibility. But looking at the many extensions available on the NuGet, its absolutely worth it.  <p><strong>Building your own extensions </strong> <p>As an example, let's create an extension method on <strong>DirectionInfo</strong> like this  <p><font size="1" face="Consolas">public static class DirectoryInfoExtensions <br></font><font size="1"><font face="Consolas">{ <br></font><font face="Consolas">&nbsp; public static DirectoryInfoAssertions Should(this DirectoryInfo instance) </font></font></p> <p><font size="1" face="Consolas">&nbsp;&nbsp;&nbsp; { <br></font><font size="1" face="Consolas">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new DirectoryInfoAssertions(instance); <br></font><font size="1"><font face="Consolas">&nbsp;&nbsp;&nbsp; } <br></font><font face="Consolas">} </font></font></p> <p>It's the returned assertions class that provides the actually assertion methods. You don't need to, but if you sub-class the self-referencing generic class <a href="https://github.com/dennisdoomen/FluentAssertions/blob/31fff27a925c11e2b9b7b5f92fd5b0b5828e1015/Src/Core/Primitives/ReferenceTypeAssertions.cs">ReferenceTypeAssertions&lt;TSubject, TSelf&gt;</a>, you'll already get methods like <strong>BeNull</strong>, <strong>BeSameAs</strong> and <strong>Match</strong> for free. Assuming you did, and you provided an override of the <strong>Context</strong> property so that these methods know that we're dealing with a directory, it's time for the the next step. Let's add an extension that allows you to assert that the involved directory contains a particular file.  <p><font size="1" face="Consolas">public class DirectoryInfoAssertions : <br>&nbsp;&nbsp;&nbsp; ReferenceTypeAssertions&lt;DirectoryInfo, DirectoryInfoAssertions&gt;<br>{<br>&nbsp;&nbsp;&nbsp; public DirectoryInfoAssertions(DirectoryInfo instance)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Subject = instance;<br>&nbsp;&nbsp;&nbsp; }</font></p> <p><font size="1" face="Consolas">&nbsp;&nbsp;&nbsp; protected override string Context =&gt; "directory";</font></p> <p><font size="1" face="Consolas">&nbsp;&nbsp;&nbsp; public AndConstraint&lt;DirectoryInfoAssertions&gt; ContainFile(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string filename, string because = "", params object[] becauseArgs)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Execute.Assertion<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .BecauseOf(because, becauseArgs)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ForCondition(!string.IsNullOrEmpty(filename))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .FailWith("You can't assert a file exist if you don't pass a proper name")<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Given(() =&gt; Subject.GetFiles())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .ForCondition(files =&gt; files.Any(fileInfo =&gt; fileInfo.Name.Equals(filename)))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .FailWith("Expected {context:directory} to contain {0}{reason}, but found {1}.", <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; _ =&gt; filename, files =&gt; files.Select(file =&gt; file.Name));</font></p> <p><font size="1" face="Consolas">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new AndConstraint&lt;DirectoryInfoAssertions&gt;(this);<br>&nbsp;&nbsp;&nbsp; }<br>}</font></p> <p>This is quite an elaborate example with shows some of the more advanced extensibility features. Let me highlight some things:  <ul> <li>The <strong>Subject</strong> property is used to give the base-class extensions access to the current <strong>DirectoryInfo</strong> object.  <li><strong>Execute.Assertion</strong> is the point of entrance into the internal fluent assertion API.  <li>The optional because parameter can contain <strong>string.Format</strong> style place holders which will be filled using the values provided to the <strong>becauseArgs</strong>. They can be used by the caller to provide a reason why the assertion should succeed. By passing those into the <strong>BecauseOf</strong> method, you can refer to the expanded result using the {reason} tag in the <strong>FailWith</strong> method.  <li>The <strong>Then</strong> property is just there to chain multiple assertions together. You can have more than one.  <li>The <strong>Given</strong> method allows you to perform a lazily evaluated projection on whatever you want. In this case I use it to get a list of <strong>FileInfo</strong> objects from the current directory. Notice that the resulting expression is not evaluated until the final call to <strong>FailWith</strong>.  <li><strong>FailWith</strong> will evaluate the condition, and raise the appropriate exception specific for the detected test framework. It again can contain numbered placeholders as well as the special named placeholders <strong>{context}</strong> and <strong>{reason}</strong>. I'll explain the former in a minute, but suffice to say that it displays the text "directory" at that point. The remainder of the place holders will be filled by applying the appropriate type-specific value formatter for the provided arguments. If those arguments involve a non-primitive type such as a collection or complex type, the formatters will use recursion to always use the appropriate formatter.  <li>Since we used the <strong>Given</strong> construct to create a projection, the parameters of <strong>FailWith</strong> are formed by a <strong>params</strong> array of <strong>Func&lt;T, object&gt;</strong> that give you access to the projection (such as the <strong>FileInfo[]</strong> in this particular case). But normally, it's just a <strong>params</strong> array of objects. </li></ul> <p><strong>Scoping your extensions </strong> <p>Now what if you want to reuse your newly created extension method within some other extension method? For instance, what if you want to apply that assertion on a collection of directories? Wouldn't it be cool if you can tell your extension method about the current directory? This is where the <strong>AssertionScope</strong> comes into place.  <p><font size="1" face="Consolas">public AndConstraint&lt;DirectoryInfoAssertions&gt; ContainFileInAllSubdirectories(<br>&nbsp;&nbsp;&nbsp; string filename, string because, params object[] becauseArgs)<br>{<br>&nbsp;&nbsp;&nbsp; foreach (DirectoryInfo subDirectory in Subject.GetDirectories())<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using (new AssertionScope(subDirectory.FullName))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; subDirectory.Should().ContainFile(filename, because, becauseArgs);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }</font></p> <p><font size="1" face="Consolas">&nbsp;&nbsp;&nbsp; return new AndConstraint&lt;DirectoryInfoAssertions&gt;(this);<br>}</font></p> <p> <p>Whatever you pass into its constructor will be used to overwrite the default <strong>{context}</strong> passed to <strong>FailWith</strong>.  <p><font size="1" face="Consolas">.FailWith("Expected {context:directory} to contain {0}{reason}, but found {1}.", </font> <p>So in this case, our nicely created <strong>ContainFile</strong> extension method will display the directory that it used to assert that file existed. You can do a lot more advanced stuff if you want. Just <a href="https://github.com/dennisdoomen/FluentAssertions/blob/master/Src/Core/Equivalency/EquivalencyValidator.cs#L45">check out the code</a> that is used by the structural equivalency API.  <p><strong>Rendering objects with beauty </strong> <p>Whenever Fluent Assertions raises an assertion exception, it will use value formatters to render the display representation of an object. Notice that these things are supposed to do more than just calling <strong>ToString</strong>. A good formatter will include the relevant parts and hide the relevant part. For instance, the <a href="https://github.com/dennisdoomen/FluentAssertions/blob/master/Src/Core/Formatting/DateTimeOffsetValueFormatter.cs">DateTimeOffsetValueFormatter</a> is there to give you a nice human-readable representation of a date and time with offset. It will only show the parts of that value that have non-default values. Check out <a href="https://github.com/dennisdoomen/FluentAssertions/blob/master/Tests/FluentAssertions.Shared.Specs/DateTimeOffsetValueFormatterSpecs.cs">the specs</a> to see some examples of that.  <p>You can hook-up your own formatters <a href="https://github.com/dennisdoomen/FluentAssertions/wiki#extensibility-1">in several ways</a>, but what does it mean to build your own? Well, a value formatter just needs to implement the two methods <a href="https://github.com/dennisdoomen/FluentAssertions/blob/31fff27a925c11e2b9b7b5f92fd5b0b5828e1015/Src/Core/Formatting/IValueFormatter.cs">IValueFormatter</a> declares. First, it needs to tell FA whether your formatter can handle a certain type by implementing the well-named method <strong>CanHandle(object)</strong>. The other one is there to, no surprises here, render it to a string. </p> <p><font size="1" face="Consolas">string ToString(object value, bool useLineBreaks, IList&lt;object&gt; processedObjects = null, <br>&nbsp;&nbsp;&nbsp; int nestedPropertyLevel = 0); </font></p> <p>Next to the actual value that needs rendering, this method accepts a couple of parameters worth mentioning.  <ul> <li><strong>useLineBreaks</strong> denotes that the value should be prefixed by a newline. It is used by some assertion code to force displaying the various elements of the failure message on a separate line.  <li><strong>processedObjects</strong> needs to be passed to any (recursive) call to <strong>Formatter.ToString</strong> so that it can detect cyclic dependencies and bail out in time.  <li><strong>nestedPropertyLevel</strong> is used when rendering a complex object that would involve multiple, potentially recursive, nested calls to <strong>Formatter.ToString</strong>. It allows the formatter to display its representation using an indented view. </li></ul> <p>This is what an implementation for the <strong>DirectoryInfo</strong> would look like. </p> <p align="left"> <p><font size="1" face="Consolas">public class DirectoryInfoValueFormatter : IValueFormatter<br>{<br>&nbsp;&nbsp;&nbsp; public bool CanHandle(object value)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return value is DirectoryInfo;<br>&nbsp;&nbsp;&nbsp; }</font></p> <p><font size="1" face="Consolas">&nbsp;&nbsp;&nbsp; public string ToString(object value, bool useLineBreaks, IList&lt;object&gt; processedObjects = null, int nestedPropertyLevel = 0)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string newline = useLineBreaks ? Environment.NewLine : "";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string padding = new string('\t', nestedPropertyLevel);</font></p> <p><font size="1" face="Consolas">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var info = (DirectoryInfo)value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return $"{newline}{padding} {info.FullName} ({info.GetFiles().Length} files, {info.GetDirectories().Length} directories)";<br>&nbsp;&nbsp;&nbsp; }<br>}</font></p> <p>Yeah, I do see that this API has become a bit overcomplicated, but changing it would cause some breaking changes. I'm trying to avoid these until I can find some a great incentive to have people upgrade to a major release. </p></p> <p><strong>To be or not to be a value type </strong> <p>The structural equivalency API provided by <a href="https://github.com/dennisdoomen/FluentAssertions/blob/698d015bbdde96b7df84f70ef1348d0f0a3761b1/Src/Shared/AssertionExtensions.cs#L646">ShouldBeEquivalentTo</a> and <a href="https://github.com/dennisdoomen/FluentAssertions/blob/698d015bbdde96b7df84f70ef1348d0f0a3761b1/Src/Shared/AssertionExtensions.cs#L610">ShouldAllBeEquivalentTo</a> is arguably the most powerful, but also most complex, part of Fluent Assertions. And to make things worse, you can extend and adapt the default behavior quite extensively. For instance, to determine whether FA needs to recursive into a complex object, it needs to know what object should be treated as a complex object. An object that has properties isn't necessarily a complex type that you want to recurse on. <strong>DirectoryInfo</strong> has properties, but you don't want FA to just traverse its properties. So, you need to tell what types should be treated as value types. The default (naive) behavior is to treat everything from the <strong>System</strong> namespace as a value type.  <p><font size="1" face="Consolas">public static Func&lt;Type, bool&gt; IsValueType = type =&gt; (type.Namespace == typeof (int).Namespace); </font> <p>But you can easily change that by setting the global AssertionOption.<a href="https://github.com/dennisdoomen/FluentAssertions/blob/master/Src/Core/AssertionOptions.cs#L35">IsValueType</a> function or temporarily using the <a href="https://github.com/dennisdoomen/FluentAssertions/blob/31fff27a925c11e2b9b7b5f92fd5b0b5828e1015/Src/Core/Equivalency/SelfReferenceEquivalencyAssertionOptions.cs#L484">ComparingByValue&lt;T&gt;</a> options for individual assertions.  <p><strong>Equivalency assertion step by step</strong>  <p>The entire structural equivalency API is built around the concept of a collection of equivalency steps that are run in a predefined order. Each step is an implementation of the <a href="https://github.com/dennisdoomen/FluentAssertions/blob/698d015bbdde96b7df84f70ef1348d0f0a3761b1/Src/Core/Equivalency/IEquivalencyStep.cs">IEquivalencyStep</a> which exposes two methods: <strong>CanHandle</strong> and <strong>Handle</strong>. You can pass your own implementation to a particular assertion call by passing it into the <a href="http://IEquivalencyS">Using</a> method (which puts it behind the final default step) or directly tweak the global AssertionOptions.<a href="https://github.com/dennisdoomen/FluentAssertions/blob/master/Src/Core/AssertionOptions.cs#L53">EquivalencySteps</a> collection. Checkout the underlying <a href="https://github.com/dennisdoomen/FluentAssertions/blob/31fff27a925c11e2b9b7b5f92fd5b0b5828e1015/Src/Core/EquivalencyStepCollection.cs">EquivalencyStepCollection</a> to see how it relates your custom step to the other steps. That said, the <strong>Handle</strong> method has the following signature:  <p><font size="1" face="Consolas">bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator parent, <br>&nbsp;&nbsp;&nbsp; IEquivalencyAssertionOptions config); </font> <p>It provides you with a couple of parameters. The <strong>context</strong> gives you access to information on the subject-under-test, the expectation and some information on where you are in a deeply nested structure. The <strong>parent</strong> allows you to perform nested assertions like the <a href="https://github.com/dennisdoomen/FluentAssertions/blob/31fff27a925c11e2b9b7b5f92fd5b0b5828e1015/Src/Core/Equivalency/StructuralEqualityEquivalencyStep.cs">StructuralEqualityEquivalencyStep</a> is doing. The <strong>config</strong> parameter provides you access to the effective configuration that should apply to the current assertion call. Using this knowledge, the simplest built-in step looks like this:  <p><font size="1" face="Consolas">public class SimpleEqualityEquivalencyStep : IEquivalencyStep<br>{<br>&nbsp;&nbsp;&nbsp; public bool CanHandle(IEquivalencyValidationContext context, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IEquivalencyAssertionOptions config)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return !config.IsRecursive &amp;&amp; !context.IsRoot;<br>&nbsp;&nbsp;&nbsp; }</font></p> <p><font size="1" face="Consolas">&nbsp;&nbsp;&nbsp; public bool Handle(IEquivalencyValidationContext context, IEquivalencyValidator <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; structuralEqualityValidator, IEquivalencyAssertionOptions config)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; context.Subject.Should().Be(context.Expectation, context.Because, context.BecauseArgs);</font></p> <p><font size="1" face="Consolas">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>&nbsp;&nbsp;&nbsp; }<br>}</font></p> <p>Since Should().<a href="https://github.com/dennisdoomen/FluentAssertions/blob/31fff27a925c11e2b9b7b5f92fd5b0b5828e1015/Src/Core/Primitives/StringAssertions.cs#L36">Be</a>() internally uses the <strong>{context}</strong> placeholder I discussed at the beginning of this article and the encompassing <a href="https://github.com/dennisdoomen/FluentAssertions/blob/31fff27a925c11e2b9b7b5f92fd5b0b5828e1015/Src/Core/Equivalency/EquivalencyValidator.cs">EquivalencyValidator</a> will use the <a href="https://github.com/dennisdoomen/FluentAssertions/blob/31fff27a925c11e2b9b7b5f92fd5b0b5828e1015/Src/Core/Execution/AssertionScope.cs">AssertionScope</a> to set-up the right context, you'll get crystal-clear messages when something didn't meet the expectation. This particular extension point is pretty flexible, but the many options <strong>ShouldBeEquivalentTo</strong> provides out-of-the-box probably means you don't need to use it.  <p><strong>About selection, matching and ordering </strong> <p>Next to tuning the value type evaluation and changing the internal execution plan of the equivalency API, there are a couple of more specific extension methods. They are internally used by some of the methods provided by the <strong>options</strong> parameter, but you can add your own by calling the appropriate overloads of the <strong>Using</strong> methods. You can even do this globally by using the static AssertionOptions.<a href="https://github.com/dennisdoomen/FluentAssertions/blob/master/Src/Core/AssertionOptions.cs#L43">AssertEquivalencyUsing</a> method.  <p>The interface <a href="https://github.com/dennisdoomen/FluentAssertions/blob/698d015bbdde96b7df84f70ef1348d0f0a3761b1/Src/Core/Equivalency/IMemberSelectionRule.cs">IMemberSelectionRule</a> defines an abstraction that defines what members (fields and properties) of the subject need to be included in the equivalency assertion operation. The main in-out parameter is a collection of <a href="https://github.com/dennisdoomen/FluentAssertions/blob/698d015bbdde96b7df84f70ef1348d0f0a3761b1/Src/Core/Equivalency/SelectedMemberInfo.cs">SelectedMemberInfo</a> objects representing the fields and properties that need to be include. However, if your selection rule needs to start from scratch, you should override IncludesMembers and return <strong>false</strong>. The rule will also get access to the configuration for the current invocation as well as some contextual information about the compile-time and run-time types of the current parent member. As an example, the <a href="https://github.com/dennisdoomen/FluentAssertions/blob/698d015bbdde96b7df84f70ef1348d0f0a3761b1/Src/Core/Equivalency/Selection/AllPublicPropertiesSelectionRule.cs">AllPublicPropertiesSelectionRule</a> looks like this:  <p><font size="1" face="Consolas">internal class AllPublicPropertiesSelectionRule : IMemberSelectionRule<br>{<br>&nbsp;&nbsp;&nbsp; public bool IncludesMembers =&gt; false;</font></p> <p><font size="1" face="Consolas">&nbsp;&nbsp;&nbsp; public IEnumerable&lt;SelectedMemberInfo&gt; SelectMembers(IEnumerable&lt;SelectedMemberInfo&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; selectedMembers, ISubjectInfo context, IEquivalencyAssertionOptions config)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return selectedMembers.Union(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; config.GetSubjectType(context).GetNonPrivateProperties()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .Select(SelectedMemberInfo.Create));<br>&nbsp;&nbsp;&nbsp; }</font></p> <p><font size="1" face="Consolas">&nbsp;&nbsp;&nbsp; public override string ToString()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "Include all non-private properties";<br>&nbsp;&nbsp;&nbsp; }<br>}</font></p> <p>Notice the override of <strong>ToString</strong>. The output of that is included in the message in case the assertion fails. It'll help the developer understand the 'rules' that were applied to the assertion.  <p>Another interface, <a href="https://github.com/dennisdoomen/FluentAssertions/blob/698d015bbdde96b7df84f70ef1348d0f0a3761b1/Src/Core/Equivalency/IMemberMatchingRule.cs">IMemberMatchingRule</a>, is used to map a member of the subject to the member of the expectation object with which it should be compared with. It's not something you likely need to implement, but if you do, checkout the built-in implementations <a href="https://github.com/dennisdoomen/FluentAssertions/blob/698d015bbdde96b7df84f70ef1348d0f0a3761b1/Src/Core/Equivalency/Matching/MustMatchByNameRule.cs">MustMatchByNameRule</a> and <a href="https://github.com/dennisdoomen/FluentAssertions/blob/698d015bbdde96b7df84f70ef1348d0f0a3761b1/Src/Core/Equivalency/Matching/TryMatchByNameRule.cs">TryMatchByNameRule</a>. It receives a <strong>SelectedMemberInfo</strong> of the subject's property, the expectation to which you need to map a property, the dotted path to it and the configuration object uses everywhere.  <p>The final interface, the <a href="https://github.com/dennisdoomen/FluentAssertions/blob/698d015bbdde96b7df84f70ef1348d0f0a3761b1/Src/Core/Equivalency/Matching/TryMatchByNameRule.cs">IOrderingRule</a>, is used to determine whether FA should be strict about the order of items in collections. The <a href="https://github.com/dennisdoomen/FluentAssertions/blob/698d015bbdde96b7df84f70ef1348d0f0a3761b1/Src/Core/Equivalency/Ordering/ByteArrayOrderingRule.cs">ByteArrayOrderingRule</a> is the one used by default, will ensure that FA isn't strict about the order, unless it involves a <strong>byte[]</strong>. The reason behind that is when ordering is treated as irrelevant, FA needs to compare every item in the one collection with every item in the other collection. Each of these comparisons might involve a recursive and nested comparison on the object graph represented by the item. This proved to cause a performance issue with large byte arrays. So I figured that byte arrays are generally used for raw data where ordering is important.  <p>Well, that's a wrap. What do you think? Does providing extension points like these help you write better unit tests? Are you missing anything? I'd love to hear your thoughts by commenting below. Oh, and follow me at <a href="https://twitter.com/ddoomen">@ddoomen</a> to get regular updates on my everlasting quest for better solutions.</p>