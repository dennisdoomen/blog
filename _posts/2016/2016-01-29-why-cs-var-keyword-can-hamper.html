---

title: Why C#'s “var” keyword can hamper maintainability
date: '2016-01-29T12:02:00.001+01:00'

tags:
- csharp coding guidelines
modified_time: '2016-01-29T12:02:28.970+01:00'
thumbnail: https://lh3.googleusercontent.com/-DKzxkYlOXXM/VqtGw58tGsI/AAAAAAAAKWI/9SlqUb7WGbc/s72-c/clip_image001%25255B4%25255D_thumb%25255B4%25255D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-15137028.post-881599956385804410
blogger_orig_url: http://www.continuousimprover.com/2016/01/why-cs-var-keyword-can-hamper.html
---

<p>Coding conventions never cease to be a great source for heated debates. However, within the C# realm, two specific topics tend to reappear occasionally. The first one is about whether or not to use underscores for class fields (but I'm not going to discuss that here). The other one is the usage of the <em>var</em> keyword. I don't know why, but during code reviews, the over-zealous usage of <em>var</em> always triggers a feeling of annoyance in me. So beware, this is going to be a very opinionated view on that.  <p>In short, in my opinion (and those of my <a href="http://www.csharpcodingguidelines.com">coding guidelines</a>) <em>var</em> should only be used if the actual type is immediately visible from the statement you're looking at. The only exception I can think of are anonymous types (often seen when using LINQ). So as far as I'm concerned, let's check out some proper usage of <em>var</em>. <p><font size="2" face="Courier New">var largeOrders = <br>&nbsp;&nbsp; from order in orders <br>&nbsp;&nbsp; where order.Items &gt; 10 and order.TotalValue &gt; 1000 <br>&nbsp;&nbsp; select new { OrderId = order.Id };</font></p> <p><font size="2" face="Courier New">var repository = new unitOfWork.GetRepository&lt;Company&gt;();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </font></p> <p><font size="2" face="Courier New">var orders = new List&lt;Order&gt;();</font></p> <p>All three examples should make it very clear what the involved type is, even if it is an anonymous type. Now for some dubious usage of <em>var</em>: <p><font size="2" face="Courier New">// I assume it's a string, but maybe it's some kind of domain-specific value type<br>var key = CommandNameResolver.GetName&lt;IncludeLogbookEntryReferenceInHandoverCommand&gt;();</font> <p><font size="2" face="Courier New">// What was that default type C# used for numbers?<br>var i =3;</font> <p><font size="2" face="Courier New">// No clue. An enumerable of DateTime maybe? And if so, why not use a TimeSpan?<br>var startOfShifts = GetShiftStartTimes();</font> <p><font size="2" face="Courier New">// What codes? Strings? Guids? Something else?<br>foreach (var code in codes) { }</font> <p>I know that modern IDEs like Visual Studio will make it easy to detect the type you're looking at, but we do most code reviews - if not all - through GitHub <a href="https://help.github.com/articles/using-pull-requests/">Pull Requests</a>. So consider this example screenshot.  <p><a href="https://lh3.googleusercontent.com/-ZVpSROLyIkg/VqtGwamCz6I/AAAAAAAAKWE/uxv__s1H6x8/s1600-h/clip_image001%25255B4%25255D%25255B6%25255D.png"><img title="clip_image001[4]" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; border-left: 0px; display: block; padding-right: 0px; margin-right: auto" border="0" alt="clip_image001[4]" src="https://lh3.googleusercontent.com/-DKzxkYlOXXM/VqtGw58tGsI/AAAAAAAAKWI/9SlqUb7WGbc/clip_image001%25255B4%25255D_thumb%25255B4%25255D.png?imgmax=800" width="640" height="68"></a> <p>When I review a Pull Request that uses a <em>var</em> and the actual type is not immediately visible, I start to wonder about a couple of things.  <ul> <li>If the <em>var</em> is assigned from a call to another method, how much information is that method returning. For instance, I wonder if it might return an entire class, even though the caller only needs a single value. A nice analogue is saying that you're returning the entire freight truck even though you only need a single parcel. Especially if the call site is passing the return value to another method, it becomes important to understand what is being passed around.  <li>If the variable name implies some kind of collection, might it be returning an IEnumerable&lt;T&gt;? If so, that may imply that its execution could be deferred. So what impact will that happen on the calling code? Is that second iteration I just noticed going to cause some weird side-effects? <li>If the statement implies a boolean outcome, will it return a nullable boolean? And if so, did the caller deal with that correctly.  <li>Does the type being used originate from a project, component or NuGet package that isn't supposed to be used in that part of the system?</li></ul> <p>I really can't answer those questions without drilling a bit deeper in the code base, which is less than trivial on Github. Worst case I might have to pull down the sources into my local repo and use Visual Studio to understand the code being changed. <p>It's widely accepted that source code is read many more times than it's written. Now imagine you have to design an architecture for a system with similar characteristics. Wouldn’t you optimize your system for reading? If so, why wouldn't you optimize your code for readability as well? Using a <em>var</em> just because you're too lazy to type the full type name sounds like a lame excuse. And if you really that lazy, install <a href="https://www.jetbrains.com/resharper/">Resharper</a> and use <a href="https://www.jetbrains.com/resharper/help/Using_var_Keyword_in_Declarations.html">ALT-ENTER</a> to quickly switch the <em>var</em> with the explicit type. And the argument that using <em>var</em> will make it more easy to refactor your code is IMHO bull. If you change the type a method returns, don't you want to make sure call sites are actually prepared for that rather than relying on compile time errors? And if it is, just use the infamous ALT-ENTER again… <p>All in all, I remain convinced that using an explicit type will help others understand your code much faster and will increase the change coupling errors will surface during code reviews. So what do you think? Let me know by commenting below. Oh, and follow me at <a href="https://twitter.com/ddoomen">@ddoomen</a> to get regular updates on my everlasting quest for better solutions. </p>