---

title: Profiling legacy code using characterization tests
date: '2016-03-10T20:42:00.001+01:00'

tags:
- Architecture
- fluid-caching
- Testing
modified_time: '2016-03-11T12:05:59.581+01:00'
thumbnail: https://lh3.googleusercontent.com/-Ee0MRbXTKPE/VuHOGT5GxlI/AAAAAAAAKXw/F9ceekA64wA/s72-c/image_thumb%25255B2%25255D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-15137028.post-83411516131210343
blogger_orig_url: http://www.continuousimprover.com/2016/03/profiling-legacy-code-using.html
---

<p>As you might have <a href="http://www.continuousimprover.com/2016/02/a-least-recently-used-cache-that-you.html">read</a>, I've been refactoring some example code for a multi-threaded cache that I got from CodeProject into a source-only NuGet package which will soon be published as <a href="https://github.com/dennisdoomen/FluidCaching">FluidCaching</a>. Since this cache has been built to be very performant, the internal algorithms are not trivial to grasp. The fact that the code doesn't meet any <a href="http://csharpguidelines.codeplex.com/">coding conventions</a>, doesn't have any unit tests and clearly violates all SOLID principles, doesn't help either. My intention was to do some serious internal refactoring and getting rid of custom-built thread-synchronization primitives that can be replaced with built-in .NET framework classes.  <p>But how can I do that without breaking any of the existing functionality? Without unit tests, there's no safeguard that protects me from breaking things. Heck, the existing code might even contain bugs (and it did). Sure, I've used the original code in a <a href="http://www.continuousimprover.com/2016/01/evaluating-ravendb-as-embedded-database.html">RavenDB spike</a>, but that doesn't prove it will work correctly under all circumstances. A couple of years ago, <a href="https://michaelfeathers.silvrback.com/">Michael Feathers</a> wrote a <a href="http://www.amazon.co.uk/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052">brilliant book</a> full of strategies for dealing with legacy code. I don't recall his exact definition for 'legacy code', but by my definition, legacy code is every line of code that isn't covered by some automated test, isn't governed by a well-defined coding conventions, and has been designed according to accepted object-oriented design techniques such as <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Clean Code</a> and SOLID.  <p>One of the many techniques he discusses in his book is to take an existing code base and try to write a couple of automated end-to-end tests that set-up the appropriate initial state and exercise the API to observe the results. Depending on the complexity of that code base, you might not even be able to predict the outcome of the test. So just run those test cases, observe the outcome and finalize the tests by adding the necessary code to assert that the next run gives you the same results. When I did this for FluidCaching, the mere act of tweaking the input parameters and observing the outcome gave me great insight in the underlying caching algorithm. By encoding those combinations as unit tests, I was gradually building what Michael coined <em>characterization tests</em>. In a way, you're building a profile of that code base in a similar fashion as FBI Profilers <a href="http://people.howstuffworks.com/serial-killer6.htm">build a profile</a> of serial killers.  <p><a href="https://lh3.googleusercontent.com/-PmrT7W5Ctaw/VuHOF7Q2HEI/AAAAAAAAKXs/-bJ6N7u_CGI/s1600-h/image%25255B4%25255D.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; display: block; padding-right: 0px; border-top-width: 0px; margin-right: auto" border="0" alt="image" src="https://lh3.googleusercontent.com/-Ee0MRbXTKPE/VuHOGT5GxlI/AAAAAAAAKXw/F9ceekA64wA/image_thumb%25255B2%25255D.png?imgmax=800" width="640" height="427"></a>  <p>When your characterization tests cover enough of the code base (and a code coverage tool like <a href="http://www.ncrunch.net/">NCrunch</a> can really help you here), youâ€™re ready for the next steps. You can start refactoring the internal implementation while relying on the safety net provided by your tests. Or you can start isolating external dependencies like databases, file systems or other dependencies like web services or proprietary integration points. Without these, your tests will run much faster and allow you to replace expensive set-up code with more focused and readable <a href="http://www.natpryce.com/articles/000714.html">test data builders</a> or test doubles. <a href="http://jeremydmiller.com/">Jeremy D. Miller</a> used to refer to this approach as <a href="http://codebetter.com/jeremymiller/2005/10/21/haacked-on-tdd-and-jeremys-first-rule-of-tdd/">Isolate The Ugly Stuff</a>. This is an important step to more isolation. More isolation leads to more control, less fear and a faster development cycle, which allows for more aggressive refactoring.  <p>If you're far enough that the code base doesn't rely on expensive external dependencies, it's time to get rid of any static mutable state. In .NET, the use of DateTime.Now is a great example of that. Using thread-static class fields is another. This may sound like a decent idea, but just try to run your tests in parallel (like <a href="https://xunit.github.io/docs/running-tests-in-parallel.html">XUnit</a> does out-of-the-box). Chances are that your tests start to fail in a non-deterministic way. Even the <a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/">Service Locator</a> pattern promoted by Microsoft's Enterprise Library is a bad example. Obviously, all these little refactorings should open up the possibility for introducing more <a href="http://www.continuousimprover.com/2015/11/12-tips-to-write-unit-tests-that-dont.html">well-written</a> unit tests that would <a href="http://www.fluentassertions.com/">keep you out of the debugger hell</a>. Just be careful to think deeply about the scope of a unit and consider <a href="http://www.continuousimprover.com/2015/11/an-opinionated-definition-of-unit-test.html">these tips and tricks</a> while you're on it. When you have enough unit tests in place and you feel confident that you have control of your code base, you can consider getting rid of those ugly and unmaintainable characterization tests. However, I would recommend to keep a few around as integration or <a href="http://www.continuousimprover.com/2015/11/an-opinionated-definition-of-unit-test.html">subcutaneous tests</a>, provided they are easy enough to understand in case they fail.  <p>So what do you think? Did you go through a similar exercise before? I'd love to hear about those experiences by commenting below. Oh, and please follow me at <a href="https://twitter.com/ddoomen">@ddoomen</a> to get regular updates on my everlasting quest for better solutions.</p>