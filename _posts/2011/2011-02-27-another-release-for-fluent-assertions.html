---

title: Another release for Fluent Assertions
date: '2011-02-27T13:57:00.001+01:00'

tags:
- dotnetmag
- C#
- Silverlight
- Quality
- Testing
modified_time: '2011-02-27T14:20:55.124+01:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-6979265347017933613
blogger_orig_url: http://www.continuousimprover.com/2011/02/another-release-for-fluent-assertions.html
---

<p>It’s only February, but I’ve received so many requests from the community that another release of Fluent Assertions was easily warranted. </p>  <p><strong>New Features</strong></p>  <ul>   <li>Somebody working under the name of CtrlAltDel pointed me at the little-known fact that floating point variables are inheritably inaccurate and should never be compared for equality (read <a href="http://csharpindepth.com/Articles/General/FloatingPoint.aspx">this article</a> for a better explanation). Consequently <font face="Courier New">Should().Be()</font> and <font size="2" face="Courier New">Should().NotBe()</font> are no longer available for floats and doubles anymore. Instead, use the following method specifically designed for comparing floating point variables.       <br />      <br /><font face="Courier New"><span class="kwrd">float</span> <span class="kwrd">value</span> = 3.1415927F;         <br /><span class="kwrd">value</span>.Should().BeApproximately(3.14F, 0.001F</font>);       <br />      <br />This will verify that the value of the <font face="Consolas">float</font> is between 3.139 and 3.141.       <br /></li>    <li>As part of dealing with floating point comparison, I’ve also added a <font face="Courier New">BeInRange()</font> method available for all numeric types (both integral as well floating point based).       <br />      <br /><font face="Courier New">theInt.Should().BeInRange(1,10);        <br /></font></li>    <li>The assertions currently offered for all (nullable) integral types are now also available for bytes and shorts.      <br /></li>    <li>With version 1.4, you no longer have to use the <font face="Consolas">TimeSpan</font> class directly and can instead use extension methods to convert a number to a <font face="Consolas">TimeSpan</font>.       <br />      <br /><font face="Courier New">theDatetime        <br />&#160; .Should()         <br />&#160; .BeLessThan(10.Minutes())         <br />&#160; .Before(otherDatetime);         <br /></font>      <br />Other examples include <font face="Courier New">10.Minutes()</font>, <font face="Courier New">2.Hours()</font>, <font face="Courier New">1.Days()</font>, <font face="Courier New">2.Days()</font> and even <font face="Courier New">600.Milliseconds()        <br /></font></li>    <li><span class="rem">As part of a patch, Ruben Rorije introduced a set of dedicated methods that apply to <font face="Consolas">TimeSpans</font> directly:         <br />        <br /><font face="Courier New">timespan.Should().Be(12.Hours()); </font>        <br /></span></li>    <li>In earlier versions it was possible to include an assertion on an exception property using the <font face="Courier New">.And.</font> property. Jonne Kats proposed an alternative syntax for doing the same by chaining or more calls to the <font face="Consolas">Where()</font> method       <br />      <br /><font color="#30332d" size="2" face="Courier New">Action act = () =&gt; subject.Foo(<span class="kwrd">null</span>));         <br />        <br />act         <br />&#160; .ShouldThrow&lt;ArgumentNullException&gt;()         <br />&#160; .Where(e =&gt; e.Message.StartsWith(“did”));         <br />        <br /><font face="Arial">You can chain multiple calls to Where to further restrict the assertion.          <br /></font></font></li>    <li>In version 1.3 I introduced a very <a href="http://www.dennisdoomen.net/2011/01/verifying-propertychanged-events-in.html">convenient syntax</a> for asserting that a particular event was raised. You can now also do the opposite; asserting that a particular event was not raised.       <br />      <br /><font face="Consolas"><font face="Courier New">subject          <br />&#160; .ShouldNotRaisePropertyChangeFor(x =&gt; x.SomeProperty);           <br /></font>        <br /></font>And if your project is .NET 3.5 or 4.0 based, you can do that with any kind of event.       <br />      <br /><font face="Courier New">subject.ShouldNotRaise(“SomeOtherEvent”);        <br /></font></li>    <li>Based on an idea by Ruben Rorije, I’ve introduced a method to assert that the execution time of a particular method or action does not exceed a predefined value. To verify the execution time of a method, use the following syntax:      <br />      <br /><font face="Courier New">var subject = <span class="kwrd">new</span> SomePotentiallyVerySlowClass();         <br />        <br />subject         <br />&#160; .ExecutionTimeOf(s =&gt; s.ExpensiveMethod())         <br />&#160; .ShouldNotExceed(500.Milliseconds());</font>       <br />      <br />Alternatively, to verify the execution time of an arbitrary <font face="Courier New">Action</font>, use this syntax:       <br />      <br /><font face="Courier New">Action someAction = () =&gt; Thread.Sleep(510);        <br />        <br />someAction         <br />&#160; .ExecutionTime().ShouldNotExceed(100.Milliseconds());         <br /></font>      <br />Since it doesn’t make sense to do something like that in Silverlight, it is only available in the .NET 3.5 and .NET 4.0 versions of Fluent Assertions. </li> </ul>  <p><strong>Breaking Changes</strong></p>  <ul>   <li>To clean up the project, I’ve moved the assertion classes to a dedicated folder, and consequently, to a different namespace. So if you’ve been extending the built-in assertion classes, you may have to fix some namespace references. </li> </ul>  <p><strong>Improvements / Bugs Fixed</strong></p>  <ul>   <li>Fixed a bug where, under very specific circumstances, it seems that the Garbage Collector was cleanup up some of the data structures needed for the event monitoring functionality. </li>    <li>For those already extending Fluent Assertions, I’ve introduced a fluent syntax for the internal validation logic and harmonized failure message generation:      <br />      <pre class="csharpcode">Execute.Verification<br />  .ForCondition(Subject != null)<br />  .BecauseOf(reason, reasonArgs)<br />  .FailWith(<span class="str">&quot;Expected object not to be {1}{0}&quot;</span>, null);</pre><br />  </li><br /></ul><br /><br /><p>You can download this new release from its <a href="http://fluentassertions.codeplex.com/releases/view/61705">CodePlex page</a>, or, if you are as enthusiastic about <a href="http://nuget.org/Packages/Packages/Details/FluentAssertions-1-4-0-0">NuGet</a> as I am, simply get it using the Add Library Package Reference option from within Visual Studio.</p>  