---

title: Asserting object graph equivalence using Fluent Assertions 2.0
date: '2012-09-03T09:32:00.000+02:00'

tags: 
modified_time: '2012-09-03T09:32:20.386+02:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-2578348596433711939
blogger_orig_url: http://www.continuousimprover.com/2012/09/asserting-object-graph-equivalence.html
---

<div>As promised in the <a href="http://www.dennisdoomen.net/2012/08/breaking-with-past-orfluent-assertions.html">announcement</a> about version 2.0, I will&nbsp;finally explain&nbsp;the details behind the new extension methods for asserting that two object graphs are equivalent. For the record, these new extension methods are going to supersede the old <span style="font-family: &quot;Courier New&quot;, Courier, monospace;">ShouldHave()</span> method somewhere in a next major version. Internally the old methods are already using the new comparison engine, but new functionality will only be available through the new methods.<br /><strong><br /></strong><strong>Selecting the right properties</strong></div><div>Consider the class <span style="font-family: Courier New, Courier, monospace;">Order </span>and its wire-transfer equivalent <span style="font-family: Courier New, Courier, monospace;">OrderDto </span>(a so-called <a href="http://martinfowler.com/eaaCatalog/dataTransferObject.html">DTO</a>). Suppose also that an order has one or more <span style="font-family: Courier New, Courier, monospace;">Products </span>and an associated <span style="font-family: Courier New, Courier, monospace;">Customer</span>. Coincidentally, the <span style="font-family: Courier New, Courier, monospace;">OrderDto </span>will have one or more <span style="font-family: Courier New, Courier, monospace;">ProductDtos</span> and a corresponding <span style="font-family: Courier New, Courier, monospace;">CustomerDto</span>. Now if you want to make sure that all the properties of all the objects in the <span style="font-family: Courier New, Courier, monospace;">OrderDto </span>object graph match the equally named properties of the <span style="font-family: Courier New, Courier, monospace;">Order </span>object graph, you can do this.</div><div></div><div><br /><span style="font-family: Courier New, Courier, monospace;">orderDto.ShouldBeEquivalentTo(order);</span></div><div></div><div><br />In contrast to the <span style="font-family: Courier New, Courier, monospace;">ShouldHave()</span> extension method, the comparison is recursive by default and all properties of the <span style="font-family: Courier New, Courier, monospace;">OrderDto</span> must be available on the <span style="font-family: Courier New, Courier, monospace;">Order</span>. If not, an exception is thrown. You can override this behavior in different ways. For instance, you may only want to include the properties both object graphs have:<br /><br /><span style="font-family: Courier New, Courier, monospace;">orderDto.ShouldBeEquivalentTo(order, options =&gt; <br />&nbsp; &nbsp; options.ExcludingMissingProperties());</span></div><div></div><div><br />You can also exclude certain (potentially deeply nested) properties using the<span style="font-family: Courier New, Courier, monospace;"> Excluding()</span> method.</div><div></div><div><br /><span style="font-family: Courier New, Courier, monospace;">orderDto.ShouldBeEquivalentTo(order, options =&gt;&nbsp;</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; options.Excluding(o =&gt; o.Customer.Name));</span></div><div></div><div><br />Obviously, <span style="font-family: Courier New, Courier, monospace;">Excluding()</span> and <span style="font-family: Courier New, Courier, monospace;">ExcludingMissingProperties()</span> can be combined. Maybe farfetched, but you may even decide to exclude a property on a particular nested object by its index.</div><div></div><div><br /><span style="font-family: Courier New, Courier, monospace;">orderDto.ShouldBeEquivalentTo(order, options =&gt; <br />&nbsp; &nbsp; options.Excluding(o =&gt; o.Products[1].Status));</span></div><div></div><div><br />The <span style="font-family: Courier New, Courier, monospace;">Excluding()</span> method on the options object also takes a lambda expression that offers a bit more flexibility for deciding what property to include.</div><div></div><div><br /><span style="font-family: Courier New, Courier, monospace;">orderDto.ShouldBeEquivalentTo(order, options =&gt; options</span></div><div><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; .Excluding(ctx =&gt; ctx.PropertyPath == "Level.Level.Text"));</span></div><div></div><div><br />This expression has access to the property path, the property info and the subject’s run-time and compile-time type. You could also take a different approach and explicitly tell FA which properties to include.</div><div></div><div><br /><span style="font-family: Courier New, Courier, monospace;">orderDto.ShouldBeEquivalentTo(order, options =&gt; options</span></div><div><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; .Including(o =&gt; o.OrderNumber)</span></div><div><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; .Including(o =&gt; o.Date));</span></div><div></div><div><strong><br /></strong><strong>Overriding and collections</strong></div><div>In addition to influencing the properties that are including in the comparison, you can also override the actual assertion operation that is executed on a particular property. </div><div></div><div><br /><span style="font-family: Courier New, Courier, monospace;">orderDto.ShouldBeEquivalentTo(order, options =&gt; options</span></div><div><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; .Using&lt;DateTime&gt;(ctx =&gt; ctx.Date.Should().BeCloseTo(ctx.Date, 1000))</span></div><div><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; .When(info =&gt; info.PropertyPath.EndsWith("Date")));</span></div><div></div><div><br />If you want to do this for all properties of a certain type, you can shorten the above call like this.</div><div></div><div><br /><span style="font-family: Courier New, Courier, monospace;">orderDto.ShouldBeEquivalentTo(order, options =&gt; options </span></div><div><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; .Using&lt;DateTime&gt;(ctx =&gt; ctx.Date.Should().BeCloseTo(ctx.Date, 1000)) </span></div><div><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; .WhenTypeIs&lt;DateTime&gt;();</span></div><div></div><div><br />The original <span style="font-family: Courier New, Courier, monospace;">ShouldHave()</span> extension method does support collections now, but it doesn’t allow you to influence the comparison based on the actual collection type. The new extension method <span style="font-family: Courier New, Courier, monospace;">ShouldAllBeEquivalentTo()</span> does support that so you can now take the 2nd example from the post and apply it on a collection of <span style="font-family: Courier New, Courier, monospace;">OrderDto</span>s.</div><div></div><div><br /><span style="font-family: Courier New, Courier, monospace;">orderDtos.ShouldAllBeEquivalentTo(orders, options =&gt; &nbsp;&nbsp;</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; options.Excluding(o =&gt; o.Customer.Name));</span></div><div></div><div><strong><br /></strong><strong>Extensibility</strong></div><div>Internally the comparison process consists of three phases.</div><div><br /><ol><li>Select the properties of the subject object to include in the comparison.</li><li>Find a matching property on the expectation object and decide what to do if it can’t find any.</li><li>Select the appropriate assertion method for the property’s type and execute it.</li></ol></div><div></div><div>Each of these phases is executed by one or more implementations of <span style="font-family: Courier New, Courier, monospace;">ISelectionRule</span>, <span style="font-family: Courier New, Courier, monospace;">IMatchingRule </span>and <span style="font-family: Courier New, Courier, monospace;">IAssertionRule </span>that are maintained by the <span style="font-family: Courier New, Courier, monospace;">EquivalencyAssertionOptions</span>. The <span style="font-family: Courier New, Courier, monospace;">ExcludePropertyByPredicateSelectionRule </span>for example, is added to the collection of selection rules when you use the <span style="font-family: Courier New, Courier, monospace;">Excluding(property expression)</span> method on the options parameter of <span style="font-family: Courier New, Courier, monospace;">ShouldBeEquivalentTo()</span>. Even the <span style="font-family: Courier New, Courier, monospace;">Using().When()</span> construct in the previous section is doing nothing more than inserting an <span style="font-family: Courier New, Courier, monospace;">AssertionRule&lt;TSubject&gt;</span> in to the list of assertion rules. Creating your own rule is quite straightforward.&nbsp;</div><ol><li>Choose the appropriate phase that the rule should influence</li><li>Select the corresponding interface</li><li>Create a class that implements this interface</li><li>Add it to the <span style="font-family: Courier New, Courier, monospace;">ShouldBeEquivalentTo()</span> call using the <span style="font-family: Courier New, Courier, monospace;">Using()</span> method on the options parameters.</li></ol><div><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp;</span><span style="font-family: 'Courier New', Courier, monospace;">&nbsp;</span><span style="font-family: Courier New, Courier, monospace;">subject.ShouldBeEquivalentTo(expected, options =&gt; options</span></div><div><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp;&nbsp;</span><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp;</span><span style="font-family: 'Courier New', Courier, monospace;">&nbsp;</span><span style="font-family: 'Courier New', Courier, monospace;">.Using(new ExcludeForeignKeysSelectionRule()))</span></div><div></div><div><br />That’s it for now. As usual, for questions, remarks or suggestions, you can use the <a href="http://fluentassertions.codeplex.com/discussions">Discussions</a> page, <a href="http://stackoverflow.com/questions/tagged/fluent-assertions">StackOverflow</a>, or you can contact me directly by <a href="mailto:dennis.doomen@avivasolutions.nl">email</a> or <a href="http://twitter.com/ddoomen">Twitter</a>.</div><div></div><div><strong><br /></strong><strong>Off topic</strong>: Although we’re still on CodePlex, the source code of Fluent Assertions is now stored in a <a href="http://git-scm.com/documentation">Git</a> repository. That should make it a whole lot easier for contributors to fork the code, write a nice improvement, and send us a pull request. </div>