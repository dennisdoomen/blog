---

title: 'ALM Practices Part 3: Unit Testing & TDD'
date: '2010-03-02T14:09:00.003+01:00'

tags:
- ALM Practices
- ALM
modified_time: '2010-08-17T09:41:45.787+02:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-3889099642165695903
blogger_orig_url: http://www.continuousimprover.com/2010/03/tfs-development-practices-part-3-unit.html
---

<h6></h6> <strong>What is it?</strong>  <br />In essence, Test Driven Development (TDD) is a practice in which the interface and the behavior of a component is designed while writing a unit test. In other words, you typically start writing a test case and define the exact members, behavior and names on the fly. In fact, the word <i>Test</i> in TDD is misleading at the least, because the whole practice is really a design methodology that promotes creating testable loosely coupled software. And since this is going to be a difficult endeavor without applying the right design principles, you usually end up with a maintainable and extensible system which by incidence also includes a high code coverage. Without TDD, these same goals are very difficult to reach.  <br /><strong>Why would you do that?</strong>  <br />  <ul>   <li>Because a seemingly small chance might have unexpected side effects caused by errors in the design or an solution that is too complex. </li>    <li>Because the simple practice of writing a readable unit test forces you to create code that is testable. </li>    <li>Because you will discover new scenarios while writing those tests that you usually do not find until you start running into bugs while testing the actual system. </li>    <li>Because a readable unit tests helps other developers to understand how to use the component’s API. </li>    <li>Because a set of well written comprehensible unit tests prevent you from long hours into the Visual Studio debugger, both during initial development as well as during an extensive system test. </li>    <li>Because you will be the first user of your component’s API which should stimulate you to really think carefully about how other users should use the API. </li>    <li>Because having a high coverage should encourage you to proactively refactor and improve your code base while adding new features. </li> </ul> <strong>What’s the bare minimum you need to do?</strong>  <br />  <ul>   <li>Write <a href="http://www.markhneedham.com/blog/2008/12/04/what-make-a-good-unit-test/">Intention revealing</a> unit tests for all business critical functionality, technically complex code, components that are reused often and parts that are difficult to test manually. </li>    <li>Make sure that test code complies to the same high standards as production code. Test specifications are first class citizens as well. </li> </ul> <b>What’s the usual thing to do?</b>  <br />  <ul>   <li>Use TDD for everything you create and apply the <a href="http://jamesshore.com/Blog/Microsoft-Gets-TDD-Completely-Wrong.html">red-green-refactor</a> mantra rigorously. </li>    <li>Use the tests as your starting point for Peer Reviews. Every TFS task, user story or other functional work item should be associated with a set of tests that define the expected behavior of a component. As a reviewer you first review those tests to make sure the behavior matches your expectations, before you move on to the actual production code. </li> </ul> <b>How do you do that?</b>  <br />  <ul>   <li>Read all TDD-related articles pointed to from <a href="http://codebetter.com/blogs/jeremy.miller/archive/2006/08/07/148071.aspx">this</a> blog post written by Jeremy D. Miller, and the article <a href="http://xunitpatterns.com/Principles%20of%20Test%20Automation.html">Principes of Test Automation</a> from the book <a href="http://www.amazon.com/xUnit-Test-Patterns-Refactoring-Addison-Wesley/dp/0131495054">xUnit Patterns</a>. These should give you a kick start on unit testing and TDD. </li>    <li>On your project site or dashboard, explicitly state which projects within your Visual Studio solution should be fully covered by unit tests and why (not). </li>    <li>Active Code Coverage and strive for a minimum of 90% coverage. </li>    <li><a href="http://blogs.msdn.com/buckh/archive/2007/08/14/tfs-2008-a-basic-guide-to-team-build-2008.aspx">Configure</a> a Daily Build that runs all unit tests and use the Quality Indicators report from the TFS MSF Agile process template to monitor the code coverage and the success rate of your tests over time. This report also shows the amount of code that still changes, which is very helpful when the team approaches an important deadline. </li>    <li>Configure your build in such a way that it automatically creates a bug upon any test failure and make sure the first team member that enters the office feels responsible for fixing that. </li>    <li>Automatically deploy test data required by your integration tests (unit tests that require a database) using a <a href="http://www.code-magazine.com/Article.aspx?quickid=0712152">Database Project</a>. </li>    <li>Consider reading the entire <a href="http://www.amazon.com/xUnit-Test-Patterns-Refactoring-Addison-Wesley/dp/0131495054">xUnit Patterns</a> book. It contains invaluable resources on the organizational, technical and practical aspects of unit testing in large teams. </li> </ul>  