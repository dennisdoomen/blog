---

title: The curious case of the unsolved extension methods
date: '2010-03-24T10:56:00.001+01:00'

tags:
- dotnetmag
- Quality
- Testing
modified_time: '2010-03-24T10:56:59.283+01:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-203821915504523334
blogger_orig_url: http://www.continuousimprover.com/2010/03/curious-case-of-unsolved-extension.html
---

<p>As part of my effort to improve the type-safety of <a href="http://fluentassertions.codeplex.com/">Fluent Assertions</a>, I’ve been investigating the possibility to use C# extension methods all the way. Unfortunately I think I’ve ran into the limitations of C# 3.0 (and C# 4.0 since it doesn’t add anything useful for this). Essentially, I’d like to do the following things.&#160;&#160; </p>  <div style="font-family: verdana; background: white; color: black; font-size: 9pt">   <div style="font-family: verdana; background: white; color: black; font-size: 9pt">     <p style="margin: 0px"><span style="color: blue">var</span> someList = <span style="color: blue">new</span> <span style="color: #2b91af">List</span>&lt;<span style="color: blue">string</span>&gt; {<span style="color: #a31515">&quot;hello world&quot;</span>};</p>      <p style="margin: 0px">someList.Should().HaveCount(1);</p>      <p style="margin: 0px">someList.Should().Contain(s =&gt; s.Length &gt; 0);</p>   </div> </div>  <p>The first one is easy because it does not require any type-specific extensions and can be implemented by the following piece of code:</p>  <div style="font-family: verdana; background: white; color: black; font-size: 9pt">   <p style="margin: 0px"><span style="color: blue">static</span> <span style="color: blue">class</span> <span style="color: #2b91af">Extensions</span></p>    <p style="margin: 0px">{</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">static</span> <span style="color: #2b91af">EnumerableConstraints</span> Should(<span style="color: blue">this</span> <span style="color: #2b91af">IEnumerable</span> subject)</p>    <p style="margin: 0px">&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">return</span> <span style="color: blue">new</span> <span style="color: #2b91af">EnumerableConstraints</span>();</p>    <p style="margin: 0px">&#160;&#160;&#160; }</p>    <p style="margin: 0px">}</p> </div>  <p></p>  <p></p>  <div style="font-family: verdana; background: white; color: black; font-size: 9pt">   <div style="font-family: verdana; background: white; color: black; font-size: 9pt">     <p style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">class</span> <span style="color: #2b91af">EnumerableConstraints</span></p>      <p style="margin: 0px">{</p>      <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> ShouldConstraint(<span style="color: #2b91af">IEnumerable</span> subject) { }</p>      <p style="margin: 0px">&#160;</p>      <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">void</span> HaveCount(<span style="color: blue">int</span> expectedCount)&#160; { }</p>      <p style="margin: 0px">}</p>   </div> </div>  <p>The second one is more tricky. In order for the Contain() method to take a lambda expression on a List&lt;string&gt;, it needs to know the actual type of items in the IEnumerable collection. We can fix that by changing the type of the <em>subject</em> parameter to IEnumerable&lt;T&gt; and pass the &lt;T&gt; type parameter to the class that exposes the actual assertion methods:</p>  <div style="font-family: verdana; background: white; color: black; font-size: 9pt">   <div style="font-family: verdana; background: white; color: black; font-size: 9pt">     <p style="margin: 0px"><span style="color: blue">static</span> <span style="color: blue">class</span> <span style="color: #2b91af">Extensions</span></p>      <p style="margin: 0px">{</p>      <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">static</span> <span style="color: #2b91af">EnumerableConstraints</span>&lt;T&gt; Should&lt;T&gt;(<span style="color: blue">this</span> <span style="color: #2b91af">IEnumerable</span>&lt;T&gt; subject)</p>      <p style="margin: 0px">&#160;&#160;&#160; {</p>      <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">return</span> <span style="color: blue">new</span> <span style="color: #2b91af">EnumerableConstraints</span>&lt;T&gt;(subject);</p>      <p style="margin: 0px">&#160;&#160;&#160; }        <br />}</p>      <p style="margin: 0px">&#160;</p>      <div style="font-family: verdana; background: white; color: black; font-size: 9pt">       <p style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">class</span> <span style="color: #2b91af">EnumerableConstraints</span>&lt;T&gt;</p>        <p style="margin: 0px">{</p>        <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">void</span> HaveCount(<span style="color: blue">int</span> expectedCount) { }</p>        <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">void</span> Contain(<span style="color: #2b91af">Func</span>&lt;T, <span style="color: blue">bool</span>&gt; predicate) { }</p>        <p style="margin: 0px">}</p>     </div>   </div> </div>  <p>That solves our initial two requirements, so let’s add another one. I’d like to be able to use a lambda expression on any possible type. Something like this:</p>  <p>var dto = new FindOrdersDto { CustomerName = “blah”, MaxItems = 10 };    <br />dto.Should().Match(d =&gt; d.MaxItems &lt; 100);</p>  <p>The first idea that pops up in my mind is to add an overload of Should&lt;T&gt; to the Extensions class, like this:</p>  <div style="font-family: verdana; background: white; color: black; font-size: 9pt">   <p style="margin: 0px"><span style="color: blue">static</span> <span style="color: blue">class</span> <span style="color: #2b91af">Extensions</span></p>    <p style="margin: 0px">{</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">static</span> <span style="color: #2b91af">EnumerableConstraints</span>&lt;T&gt; Should&lt;T&gt;(<span style="color: blue">this</span> <span style="color: #2b91af">IEnumerable</span>&lt;T&gt; subject) { }       <br /></p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">static</span> <span style="color: #2b91af">BasicConstraints</span> Should&lt;T&gt;(<span style="color: blue">this</span> T subject) { }</p>    <p style="margin: 0px">}</p> </div>  <p>Unfortunately, this overload takes precedence over the overload taking an IEnumerable&lt;T&gt; and breaks the first working example. That’s a real bummer. If only I could use a <em>where </em>constraint stating that the &lt;T&gt; does <em>not</em>&#160; comply with a specific constraint. For instance</p>  <div style="font-family: verdana; background: white; color: black; font-size: 9pt">   <p style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">static</span> <span style="color: #2b91af">BasicConstraints</span> Should&lt;T&gt;(<span style="color: blue">this</span> T subject) <span style="color: blue">where <strong>not</strong></span> T : <span style="color: #2b91af">IEnumerable</span></p> </div>  <p></p>  <p>I’ve also tried to change the HaveCount(), Contain() and Match() methods into extension methods on a single generic class ShouldConstraints&lt;T&gt; like this:</p>  <p style="margin: 0px"><span style="color: blue">static</span> <span style="color: blue">class</span> <span style="color: #2b91af">Extensions</span></p>  <p style="margin: 0px">{</p>  <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">static</span> <span style="color: #2b91af">ShouldConstraints</span>&lt;T&gt; Should&lt;T&gt;(<span style="color: blue">this</span> T subject)</p>  <p style="margin: 0px">&#160;&#160;&#160; {</p>  <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">return</span> <span style="color: blue">new</span> <span style="color: #2b91af">ShouldConstraints</span>&lt;T&gt;(subject);</p>  <p style="margin: 0px">&#160;&#160;&#160; } </p>  <p style="margin: 0px">&#160;</p>  <div style="font-family: verdana; background: white; color: black; font-size: 9pt">   <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">static</span> <span style="color: #2b91af">ShouldConstraints</span>&lt;T&gt; HaveCount&lt;T, TItem&gt;(</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">this</span> <span style="color: #2b91af">ShouldConstraints</span>&lt;T&gt; constraints, <span style="color: blue">int</span> expectedCount) <span style="color: blue">where</span> T : <span style="color: #2b91af">IEnumerable</span>&lt;TItem&gt; { }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">static</span> <span style="color: #2b91af">ShouldConstraints</span>&lt;T&gt; Contain&lt;T, TItem&gt;(</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">this</span> <span style="color: #2b91af">ShouldConstraints</span>&lt;T&gt; constraints, <span style="color: #2b91af">Func</span>&lt;TItem, <span style="color: blue">bool</span>&gt; predicate) { }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> <span style="color: blue">static</span> <span style="color: #2b91af">ShouldConstraints</span>&lt;T&gt; Match&lt;T, TItem&gt;(</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span style="color: blue">this</span> <span style="color: #2b91af">ShouldConstraints</span>&lt;T&gt; constraints, <span style="color: #2b91af">Func</span>&lt;TItem, <span style="color: blue">bool</span>&gt; predicate) { }</p> </div>  <p style="margin: 0px"></p>  <p style="margin: 0px">}</p>  <p style="margin: 0px">&#160;</p>  <div style="font-family: verdana; background: white; color: black; font-size: 9pt">   <p style="margin: 0px"><span style="color: blue">class</span> <span style="color: #2b91af">ShouldConstraints</span>&lt;T&gt;</p>    <p style="margin: 0px">{</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">public</span> ShouldConstraints(T subject)</p>    <p style="margin: 0px">&#160;&#160;&#160; {</p>    <p style="margin: 0px">&#160;&#160;&#160;&#160;&#160;&#160;&#160; Subject = subject;</p>    <p style="margin: 0px">&#160;&#160;&#160; }</p>    <p style="margin: 0px">&#160;</p>    <p style="margin: 0px">&#160;&#160;&#160; <span style="color: blue">protected</span> T Subject { <span style="color: blue">get</span>; <span style="color: blue">set</span>; }</p>    <p style="margin: 0px">}</p> </div>  <p>This compiles fine, but causes the compiler to complain about missing type parameters because it is unable to infer these from the usage. This forces us to use this rather ugly syntax:</p>  <div style="font-family: verdana; background: white; color: black; font-size: 9pt">   <p style="margin: 0px"><span style="color: blue">var</span> someList = <span style="color: blue">new</span> <span style="color: #2b91af">List</span>&lt;<span style="color: blue">string</span>&gt; {<span style="color: #a31515">&quot;hello world&quot;</span>};</p>    <p style="margin: 0px">someList.Should().HaveCount&lt;<span style="color: #2b91af">List</span>&lt;<span style="color: blue">string</span>&gt;, <span style="color: blue">string</span>&gt;(1);</p>    <p style="margin: 0px">someList.Should().Contain&lt;<span style="color: #2b91af">List</span>&lt;<span style="color: blue">string</span>&gt;, <span style="color: blue">string</span>&gt;(s =&gt; s.Length &gt; 0);</p> </div>  <p>Other solutions that crossed my mind included testing the ability to define two extension methods with the same name and the same parameters but having different constraints such as:</p>  <p style="margin: 0px"><span style="color: blue">public</span> <span style="color: blue">static</span>&#160;<span style="color: #2b91af">EnumerableConstraints</span> Should&lt;T&gt;(<span style="color: blue">this</span> T subject) <span style="color: blue">where </span>T : <span style="color: #2b91af">IEnumerable      <br /></span><span style="color: blue">public</span> <span style="color: blue">static</span>&#160;<span style="color: #2b91af">ComparableConstraints</span> Should&lt;T&gt;(<span style="color: blue">this</span> T subject) <span style="color: blue">where </span>T : <span style="color: #2b91af">IComparable</span></p>  <p>But this is, as I expected, not supported by C#.</p>  <p></p>  <p></p>  <p></p>  <p>The conclusion? Well, as far as I can tell, my problem is currently unsolvable…</p>  