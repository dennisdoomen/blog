---

title: Ingredients for well-designed OWIN middleware components - Part 3
date: '2015-07-21T08:38:00.000+02:00'

tags:
- OWIN Recipes
modified_time: '2015-10-09T10:08:48.164+02:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-240472865653746662
blogger_orig_url: http://www.continuousimprover.com/2015/07/ingredients-for-well-designed-owin_21.html
---

<span style="font-family: inherit;">In my <a href="http://www.continuousimprover.com/2015/07/ingredients-for-well-designed-owin.html">last post</a>, I talked about decoupling the construction of the OWIN pipeline from the definition of the OWIN middleware component. In this post, I'm going to talk about the next ingredient, the testing story.</span><br /><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;"><b>Ingredient 4: Testing your entire HTTP pipeline</b></span><span style="font-family: inherit;">In most projects that are building ASP.NET MVC or WebAPI controllers, I've observed two testing strategies:</span><br /><ol><span style="font-family: inherit;"><li><span style="font-family: inherit;">Test the      controller class directly by passing in strongly typed message objects and      analyzing the resulting objects.</span></li><li><span style="font-family: inherit;">Keep the controller code as      thin as possible and test the underlying service code.</span></li></span></ol><span style="font-family: inherit;"></span><br /><div lang="en-US" style="margin: 0in;"><span style="font-family: inherit;">There used to be a WebAPI self-host that you could use from inside your unit test, but it still requires an actual network port. Although slow, it can work, provided that you don't run your unit tests in parallel (the default for XUnit 2). </span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: inherit;">The beauty of OWIN is that it doesn't have a direct dependency on an actual network stack. It just defines an abstraction based on simple types like dictionaries, tasks and funcs. It's Microsoft's Katana that provides an IIS host, a console host and even a Windows Service host. So ideally, your unit test could cover the entire OWIN pipeline without the need of real network ports, nor has any restrictions when they run in parallel with other unit tests. If you use OWIN, I wrote a unit test that asserts that Piercer returns its own assemblies when run from inside the unit test runner </span><span style="font-family: Courier New, Courier, monospace;">AppDomain</span><span style="font-family: inherit;"> like this.</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">[Fact]</span></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">public async Task When_specifying_an_explicit_route_it_should_be_reachable_through_that_route()</span></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">{</span></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">&nbsp;&nbsp;&nbsp; var appBuilder = new AppBuilder();</span></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">&nbsp;&nbsp;&nbsp; appBuilder.UsePiercer(new PiercerSettings().AtRoute("/myroute"));</span></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">&nbsp;&nbsp;&nbsp; AppFunc app = appBuilder.Build();</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">&nbsp;&nbsp;&nbsp; var httpClient = new HttpClient(new OwinHttpMessageHandler(appFunc));</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">&nbsp;&nbsp;&nbsp; var result = await httpClient</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; .GetStringAsync("http://localhost/myroute/piercer/assemblies");</span><br /><span style="font-family: Courier New, Courier, monospace;"><br /></span></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">&nbsp;&nbsp;&nbsp; result.Should().Contain("Piercer.Middleware");</span></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">}</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: inherit;">Using an independent </span><span style="font-family: Courier New, Courier, monospace;">AppBuilder</span><span style="font-family: inherit;"> allows you to build an in-memory OWIN pipeline accessible through an </span><span style="font-family: Courier New, Courier, monospace;">AppFunc</span><span style="font-family: inherit;">. To send actual HTTP requests into that pipeline from a typical </span><span style="font-family: Courier New, Courier, monospace;">HttpClient</span><span style="font-family: inherit;"> object, you can use a nifty little library created by <a href="https://twitter.com/randompunter">Damian Hickey</a>, the <a href="https://www.nuget.org/packages/OwinHttpMessageHandler/">OwinHttpMessageHandler</a>. It will convert the </span><span style="font-family: Courier New, Courier, monospace;">HttpRequestMessage</span><span style="font-family: inherit;"> objects that the </span><span style="font-family: Courier New, Courier, monospace;">HttpClient</span><span style="font-family: inherit;"> client sends into the dictionary that the </span><span style="font-family: Courier New, Courier, monospace;">AppFunc</span><span style="font-family: inherit;"> expects, all without ever touching a network stack. You can check out its implementation <a href="https://github.com/damianh/OwinHttpMessageHandler/blob/master/src/OwinHttpMessageHandler/OwinHttpMessageHandler.cs">here</a>. </span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: inherit;">So imagine you're writing a middleware component that needs to communicate with the outside world. I assume you would probably add a property or method to your middleware's settings class (like </span><span style="font-family: Courier New, Courier, monospace;">PiercerSettings</span><span style="font-family: inherit;">) taking the URL to communicate with. Well, don't do that. Instead, either take an </span><span style="font-family: Courier New, Courier, monospace;">HttpClient</span><span style="font-family: inherit;"> or a </span><span style="font-family: Courier New, Courier, monospace;">Uri</span><span style="font-family: inherit;"> and an optional </span><span style="font-family: Courier New, Courier, monospace;">HttpMessageHandler</span><span style="font-family: inherit;"> instance. If you take that optional </span><span style="font-family: Courier New, Courier, monospace;">HttpMessageHandler</span><span style="font-family: inherit;">, callers can either pass in the actual URL to connect to or the aforementioned </span><span style="font-family: Courier New, Courier, monospace;">OwinHttpMessageHandler</span><span style="font-family: inherit;"> like this:</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">appBuilder.UsePiercer(new PiercerSettings()</span></div><div lang="en-US" style="margin: 0in 0in 0in 0.375in;"><span style="font-family: Courier New, Courier, monospace;">.ConnectingTo(new Uri("http://localhost"));</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: inherit;">Or within unit tests:</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">appBuilder.UsePiercer(new PiercerSettings()</span></div><div lang="en-US" style="margin: 0in 0in 0in 0.375in;"><span style="font-family: Courier New, Courier, monospace;">.ConnectingTo(new Uri("http://localhost", new OwinHttpMessageHandler(appFunc))</span></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">);</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: inherit;">The definition of the </span><span style="font-family: Courier New, Courier, monospace;">ConnectingTo</span><span style="font-family: inherit;"> method might look like this:</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">public PiercerSettings ConnectingTo(Uri uri, HttpMessageHandler handler = null)</span></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">{</span></div><div lang="en-US" style="margin: 0in 0in 0in 0.375in;"><span style="font-family: Courier New, Courier, monospace;">httpClient = new HttpClient(handler ?? new HttpClientHandler())<br />{</span></div><div lang="en-US" style="margin: 0in 0in 0in 0.75in;"><span style="font-family: Courier New, Courier, monospace;">BaseAddress = uri</span></div><div lang="en-US" style="margin: 0in 0in 0in 0.375in;"><span style="font-family: Courier New, Courier, monospace;">};</span></div><div lang="en-US" style="margin: 0in 0in 0in 0.375in;"><span style="font-family: Courier New, Courier, monospace;"><br /></span></div><div lang="en-US" style="margin: 0in 0in 0in 0.375in;"><span style="font-family: Courier New, Courier, monospace;">return this;</span></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">}</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: inherit;">Now assume that within your unit test, the component that you're connecting to should also be hosted on the same </span><span style="font-family: Courier New, Courier, monospace;">AppBuilder</span><span style="font-family: inherit;">. You can't pass in the </span><span style="font-family: Courier New, Courier, monospace;">AppFunc</span><span style="font-family: inherit;">until you've completed building the pipeline, so we're at a kind of stand-off here. You can fix that by relying on the delayed execution of lambda expressions. Just redefine the </span><span style="font-family: Courier New, Courier, monospace;">ConnectingTo</span><span style="font-family: inherit;">&nbsp;method so that it takes a </span><span style="font-family: Courier New, Courier, monospace;">Func<httpmessagehandler></httpmessagehandler></span><span style="font-family: inherit;">:</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">public PiercerSettings ConnectingTo(Uri uri, Func<httpmessagehandler>handlerFunc = null) { }</httpmessagehandler></span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: inherit;">Then, you can do this:</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">AppFunc appFunc = null;</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">appBuilder.UsePiercer(new PiercerSettings()</span></div><div lang="en-US" style="margin: 0in 0in 0in 0.375in;"><span style="font-family: Courier New, Courier, monospace;">.ConnectingTo(() =&gt; new OwinHttpMessageHandler(appFunc));</span></div><div lang="en-US" style="margin: 0in 0in 0in 0.375in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">appBuilder.UseOtherService();</span></div><div lang="en-US" style="margin: 0in 0in 0in 0.375in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: Courier New, Courier, monospace;">appFunc = appBuilder.Build();</span></div><div lang="en-US" style="margin: 0in;"><br /></div><div lang="en-US" style="margin: 0in;"><span style="font-family: inherit;">The only caveat is that your middleware component shouldn't try to access the other service until the OWIN pipeline has been fully build. If that doesn't happen until your component is receiving its first HTTP request, you'll be fine. But if your component is doing some kind of background processing, you'll have to delay that explicitly, something I'll discuss in the next ingredient.</span></div>