---

title: 'Silverlight Cookbook: Switching to another IoC Framework'
date: '2011-09-28T16:55:00.000+02:00'

tags:
- dotnetmag
- Cookbook
- Architecture
- Silverlight
modified_time: '2011-09-28T20:02:30.808+02:00'
thumbnail: http://lh4.ggpht.com/-mriE-Mtl4fs/ToIcR0fSNZI/AAAAAAAAIio/4R2Qco5Wsdk/s72-c/image_thumb%25255B2%25255D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-15137028.post-2297226719727861911
blogger_orig_url: http://www.continuousimprover.com/2011/09/silverlight-cookbook-switching-to.html
---

<p><strong>The Rationale</strong></p> <p>As long as I have been using the <a href="http://www.objectmentor.com/resources/articles/dip.pdf">Dependency Inversion Principle</a>, Microsoft Unity has always been my preferred Inversion-of-Control framework. So it’s not strange that the <a href="http://silverlightcookbook.codeplex.com/">Silverlight Cookbook</a> has been using <a href="http://unity.codeplex.com/">Unity 2</a> in both its WCF/REST layer as well as within the Silverlight client. I never even bothered looking at other frameworks, with the exception of NInject, that I used in a Windows Mobile 5 project, and <a href="http://structuremap.net/structuremap/">StructureMap</a>, of which I learned a lot while reading <a href="http://codebetter.com/jeremymiller/">Jeremy D. Miller</a>’s many posts of design patterns…</p> <p>…Until I read <a href="http://philipm.at/2011/0808/">this post</a> where Philip Mateescu compared the performance of the most popular IoC frameworks…and declared <a href="http://code.google.com/p/autofac/">Autofac</a> as the clear winner…</p> <p>Let’s be honest though. I’ve always liked Unity and managed to use it to solve all my IoC and AOP problems without too much hassle. However, an analysis of some performance issues in my latest project revealed that its AOP features were not the fastest available. Notwithstanding, I would never simply change my strategy based on a single post. In fact, <a href="http://darrencauthon.posterous.com/unity-and-lying-about-performance">some</a> claim that the comparison was faulty in the first place. But after browsing through the Autofac <a href="http://code.google.com/p/autofac/wiki/GettingStarted">documentation</a> I really became quite fond of Autofac’s strategy. I’ve always abided to the “Microsoft, unless…” philosophy, but my engineering heart couldn’t resist the temptation to try to introduce Autofac into the Silverlight Cookbook. </p> <p>So what are the advantages?</p> <p><strong>Separation between configuration and resolution</strong>. </p> <p>To be more precise, you use a ContainerBuilder to setup the dependencies like this: <br><br><a href="http://lh5.ggpht.com/-p3wRAxmCxOw/ToIcRcLxdoI/AAAAAAAAIik/CUmJkFJqu9w/s1600-h/image%25255B4%25255D.png"><img style="display: inline" title="image" alt="image" src="http://lh4.ggpht.com/-mriE-Mtl4fs/ToIcR0fSNZI/AAAAAAAAIio/4R2Qco5Wsdk/image_thumb%25255B2%25255D.png?imgmax=800" width="358" height="66"></a><br><br>And use its Build() method to construct an IContainer that you cannot change anymore. (Well, strictly speaking you can, but that doesn’t mean you should). Notice the fluent interface, one of the aspects of Autofac I like quite a lot. <br><br><a href="http://lh3.ggpht.com/-_PtJ0zbeqr0/ToIcSXGrtTI/AAAAAAAAIis/-R_h-LRsvmQ/s1600-h/image%25255B12%25255D.png"><img style="display: inline" title="image" alt="image" src="http://lh6.ggpht.com/-yKUDHNszLck/ToIcS0tcNEI/AAAAAAAAIiw/FWXR7iafC9I/image_thumb%25255B6%25255D.png?imgmax=800" width="297" height="26"></a><br><br>This separation is actually the biggest reason why it took me so much time to migrate the Cookbook. You have to organize your setup code so that all registrations happen at the same place. But by doing so, I’ve found that my design actually became more clean with better separation of concerns. So, unlike what you might expect, I see this as an advantage rather than a disadvantage. But beware of this when you consider migrating from Unity to Autofac.</p> <p><strong>Implicit support for factory methods</strong></p> <p>Check out the updated version of the AddNewRecipeHandler:</p> <p><a href="http://lh5.ggpht.com/-Jl-Ok1A6i8E/ToIcTpN8EfI/AAAAAAAAIi0/HjXGIfduPDQ/s1600-h/image%25255B17%25255D.png"><img style="display: inline" title="image" alt="image" src="http://lh3.ggpht.com/-UvgVUT2MKHc/ToIcUJcUtUI/AAAAAAAAIi4/l37ibmV0bBg/image_thumb%25255B9%25255D.png?imgmax=800" width="505" height="186"></a></p> <p>So instead of introducing a dedicated factory interface, you can simply add a dependency to a Func&lt;T&gt; where T is your actual dependency. Autofac will automatically inject a delegate that you can use to create new instances of that dependency at will. And you don’t have to configure anything for that. It’s the caller that decides what kind of dependency he needs. And that’s not all. Autofac will keep track of any object you create that requires explicit disposal through its IDisposable interface. If you don’t want that, simply replace Func&lt;T&gt; with Owned&lt;T&gt;, which is Autofac’s way of giving you control. If you want to make this permanent for a particular registration, append ExternallyOwned() to the registration. </p> <p><a href="http://lh5.ggpht.com/-xcSxeq6mOkw/ToIcUZFxYdI/AAAAAAAAIi8/twsjVrdrDsA/s1600-h/image%25255B22%25255D.png"><img style="display: inline" title="image" alt="image" src="http://lh3.ggpht.com/-wmWlNMmOVuY/ToIcU0idHRI/AAAAAAAAIjA/vVB4mmmdrhY/image_thumb%25255B12%25255D.png?imgmax=800" width="450" height="68"></a></p> <p><strong>Collections of dependencies</strong></p> <p>Another feature I’ve always missed in Unity is support for taking a dependency on all instances of some type. And a big difference compared to Unity is that you can register as many implementations and instances of some interface as you want, without the need to specify some unique name. </p> <p><a href="http://lh5.ggpht.com/-BhFzduGfqDI/ToIcVPUyTlI/AAAAAAAAIjE/IfMfnP50NRk/s1600-h/image%25255B27%25255D.png"><img style="display: inline" title="image" alt="image" src="http://lh5.ggpht.com/-TcJWOukhcXk/ToIcVgAINFI/AAAAAAAAIjI/XbonHzj66L8/image_thumb%25255B15%25255D.png?imgmax=800" width="577" height="66"></a></p> <p>Again, you don’t have to think about that during registration. It’s all part of Autofac’s extensive support for <a href="http://code.google.com/p/autofac/wiki/RelationshipTypes">relationship types</a>, which includes things like Lazy&lt;T&gt;, IIndex&lt;T&gt; or even Func&lt;X, Y, B&gt; if you need to parameterize the dependency somehow. And obviously you can combine those types to create some pretty advanced dependencies (although I wonder if you should).</p> <p><strong>Modules</strong></p> <p>If, you may wonder, you have to combine all type registrations in a single location, isn’t that code going to be very difficult to understand (and maintain)? Well, no. Autofac includes the notion of combining registration in so-called <a href="http://code.google.com/p/autofac/wiki/StructuringWithModules">Modules</a>. In the Cookbook I’ve used that mechanism to combine everything that is related to supporting the creating of units-of-work using NHibernate. So rather than code like this.</p> <p><a href="http://lh3.ggpht.com/-OjPFzsbApsw/ToM06ySsKFI/AAAAAAAAIjM/eW-DbrnLeWo/s1600-h/image%25255B38%25255D.png"><img style="display: inline" title="image" alt="image" src="http://lh4.ggpht.com/-s0PCMT78hdw/ToM07RyX9aI/AAAAAAAAIjQ/Jw4mWzw-QZo/image_thumb%25255B22%25255D.png?imgmax=800" width="596" height="292"></a></p> <p>I can now do something like this:</p> <p><a href="http://lh5.ggpht.com/-uljXYAOqLcs/ToM0735qUFI/AAAAAAAAIjU/ZpRjbWcKaEo/s1600-h/image%25255B48%25255D.png"><img style="display: inline" title="image" alt="image" src="http://lh3.ggpht.com/-LO5yaTEKGZs/ToM08j9R6JI/AAAAAAAAIjY/X4rXTc7Vw5s/image_thumb%25255B28%25255D.png?imgmax=800" width="509" height="20"></a></p> <p>Although the CookbookUnitOfWorkModule contains two more complex classes in its hierarchy that I introduced to simplify working with both SQL Server as well as SQLLite, the module concept makes it a breeze to work with.</p> <p><strong>Assembly Scanning</strong></p> <p>What I particularly liked in the <a href="http://mef.codeplex.com/">Managed Extensibility Framework</a> is its support for scanning a directory for assemblies and automatically registering specific types. In the previous version of the Cookbook, I created hand-written code to automatically find my command handlers to overcome Unity’s lack of such functionality. Luckily, Autofac does include <a href="http://code.google.com/p/autofac/wiki/Scanning">assembly scanning</a> out-of-the-box, and now I can do this:</p> <p><a href="http://lh4.ggpht.com/-RPjMBLEjRH8/ToM08z9ZuoI/AAAAAAAAIjc/hM-7NAhfgu0/s1600-h/image%25255B58%25255D.png"><img style="display: inline" title="image" alt="image" src="http://lh3.ggpht.com/-PhkFXk9EKbs/ToM09ZKy9PI/AAAAAAAAIjg/LuHgLGp8Ums/image_thumb%25255B34%25255D.png?imgmax=800" width="469" height="66"></a></p> <p><a href="http://lh6.ggpht.com/-qPsShSxbVHQ/ToM092YHDHI/AAAAAAAAIjk/YkvOdwCfRvg/s1600-h/image%25255B60%25255D.png"><img style="display: inline" title="image" alt="image" src="http://lh4.ggpht.com/-siYf68KNxL8/ToM0-XdDY5I/AAAAAAAAIjo/pEk3x7vOWkg/image_thumb%25255B36%25255D.png?imgmax=800" width="602" height="70"></a></p> <p><strong>No attributes</strong></p> <p>Yes, Autofac does not contain an equivalent of Unity’s <a href="http://msdn.microsoft.com/en-us/library/microsoft.practices.unity.dependencyattribute(v=pandp.20).aspx">[Dependency]</a> attribute, and I think it’s great. In fact, Autofac’s preferred dependency injection mechanism is <a href="http://martinfowler.com/articles/injection.html#ConstructorVersusSetterInjection">constructor injection</a>. It will never inject (unset) properties, unless you explicitly <a href="http://code.google.com/p/autofac/wiki/PropertyInjection">configure</a> it for that upon registration. </p> <p>I’ve never liked property/setter injection because it allows an object to have many dependencies. According to my own <a href="http://www.csharpcodingguidelines.com">coding guidelines</a> and those stated by <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Clean Code</a>, no member should ever have more than three parameters, not even the constructor. If you need that somehow, chances are your class has too much responsibility. So beware, because that is another of the pitfalls if you switch from Unity to Autofac. </p> <p><strong>Surely not everything is that great?</strong></p> <p>Well, in the beginning of my migration attempt I was a bit set back by the lack of property injection, the fact that you cannot create proxies of objects to <a href="http://code.google.com/p/autofac/wiki/DynamicProxy2">intercept</a> at any time in your code, and the explicit separation of configuration and resolution. However, after refactoring my code to accommodate for those changes, I noticed that I actually started to like those requirements. All in all, my code base has significantly improved because of those changes. But by now, it should be clear that a migration to Autofac may not be the best thing to do in most projects unless you’ve been clearly separating the responsibilities from the start. While looking back at all the code bases I’ve seen in my career, I think that ideal situation is not something you’ll encounter often….</p> <p>This article is part of a <a href="http://www.dennisdoomen.net/search/label/Cookbook">series</a> of posts dealing with all the choices and solutions used in the <a href="http://silverlightcookbook.codeplex.com/">Silverlight Cookbook</a>. If you have any comments, let me know by commenting or sending me a tweet on <a href="http://twitter.com/#!/ddoomen">@ddoomen</a>.</p>  