---

title: The magic of hiding your NuGet dependencies
date: '2016-05-24T20:33:00.001+02:00'

tags:
- components
- nuget
- a
- Architecture
modified_time: '2016-05-24T20:33:37.580+02:00'
blogger_id: tag:blogger.com,1999:blog-15137028.post-581534080596741098
blogger_orig_url: http://www.continuousimprover.com/2016/05/the-magic-of-hiding-your-nuget.html
---

<p><strong>Welcome to the dependency hell </strong> <p>While working on a little open-source <a href="https://github.com/dennisdoomen/Piercer">demo project</a>, I ran into that well-known challenge of NuGet dependency management again. This little project results in a NuGet package, that on itself also relies on <a href="https://github.com/dennisdoomen/Piercer/blob/master/Src/Piercer.Middleware/packages.config">other packages</a>. Now, if I would just add those dependencies to the .nuspec file using the <a href="https://docs.nuget.org/create/nuspec-reference#specifying-dependencies">&lt;dependencies&gt;</a> element, I'm going to put a burden on the people who want to use my package. Why? Because whenever they use my package, they'll start to depend on all the packages my package references.  <p>If my package is the only one they use, it's probably fine. But what if they use another package that also uses <a href="https://www.nuget.org/packages/newtonsoft.json/">Json.NET</a> (for instance), but they rely on an incompatible version? You can't use two different versions of the same assembly in the same process (or more specifically, the same AppDomain). If I'm using 7.1.3, they are using 7.2.1 and the involved package uses <a href="http://semver.org/">Semantic Versioning</a> (which Json.NET fortunately does), the NuGet Package Manager will happily select the higher of the two. 7.2 implies a backwards-compatible feature update of 7.1. But if they are using 8.1, which implies a major upgrade and potential breaking changes, the NuGet Package Manager will simply give up. Now imagine that my package has a lot more dependencies that can conflict with the dependencies of the code base that is using it. That's what the .NET community typically refers to as "dependency hell".  <p><strong>A way out? </strong> <p>Yes! Merge as many of the assemblies of your dependencies into the main assembly as internal types not visible to the outside world. This has some implications however. For instance, if I would merge Json.NET into my main assembly and the consuming party also uses Json.NET, at run-time, the Json classes would appear twice in the AppDomain. So even though both classes would have the same name and namespace, the CLR would treat them as completely different types. To be more specific, if I would annotate my code with the <a href="http://www.newtonsoft.com/json/help/html/serializationattributes.htm">[JsonConverter]</a> attribute and then merge the Json.NET assembly into my assembly, the other Json.NET as loaded by the consuming party wouldn't be able to recognize the attribute.  <p>What does that mean? Well, it means that you need to consider the circumstances before you make the decision whether or not merge a dependency. Let me help you with that by providing a couple of guidelines:  <ol> <li>If the types of that dependency are used on the public types of your package, you must expose that package as a NuGet package dependency.&nbsp; <li>If the package and package consumer do have to use the same version of the dependency at run-time, use a package dependency. The above mentioned example of working with Json.NET annotated types is a good example of this.  <li>If the package and package consumer don't have to use the same version of the dependency, then by all means, merge the dependency into the package. You'll make your package consumer a happy person.</li></ol> <p><strong>Hiding your dependencies </strong> <p>Obviously option 3 is the preferred option, but isn’t always possible. Sometimes you can achieve that by not directly exposing types from your internal dependencies and using smart constructs like delegates instead. For example, let's say your internal dependency has some kind of extension point that consumers of your package would need. Something like this:  <p><font size="2" face="Courier New">public interface IExtensionPoint <br></font><font size="2" face="Courier New">{ </font> <p><font size="2" face="Courier New">&nbsp; void Connect(ModuleInfo module) <br></font><font size="2" face="Courier New">} </font> <p>Your first reaction would be to take option 1 and expose the IExtensionPoint to your consumers. But rather than that, you could also define a custom ModuleInfoAdapter class which mimics some of the properties of the ModuleInfo class and expose a delegate like this:  <p><font size="2" face="Courier New">public delegate void Connect(ModuleInfoAdapter module); </font> <p>Then when the consumer passes a method or expression into that delegate, you could internally map the exposed ModuleInfoAdapter back to the actual type expected by the merged library.  <p>Another common example is the case where your package internally uses a library that supports selecting and configuring a specific library-provided algorithm (or <a href="https://en.wikipedia.org/wiki/Strategy_pattern">Strategy</a>) and you need to delegate both to your consumers. You could hide that detail by defining an abstraction on top of that algorithm and allowing your consumer to use some kind of <a href="http://www.oodesign.com/factory-method-pattern.html">Factory Method</a> to select a particular implementation of that strategy without exposing the internal implementation of it. You'd be surprised to learn what you can do with some smart applications of the <a href="http://www.oodesign.com/adapter-pattern.html">Adapter</a> and <a href="http://www.oodesign.com/bridge-pattern.html">Bridge</a> patterns, or by simply implementing certain interfaces explicitly. This may all feel like I’m over complicating things, but anything is warranted to keep your dependencies hidden.  <p><strong>To merge or to repack</strong> <p>Within the .NET world there are currently two tools to merge multiple assemblies (and their PDBs) into a single output assembly; <a href="https://www.nuget.org/packages/ilmerge">ILMerge</a> and <a href="https://github.com/gluck/il-repack">ILRepack</a>. The former has been Microsoft's official tool of choice, but hasn't received a lot of love over the last years. The latter is an open-source library that has seen many new releases since it's first inception. Which one to use? It depends. In the beginning, ILRepack lacked in support for certain edge cases, which forced us to switch back to ILMerge. On the other hand, that one didn’t properly support .NET's portable class libraries out-of-the-box. I would recommend to try ILRepack first and see how far you'll get with it. You can find an example of a <a href="v">PSake</a> script that uses ILRepack in my <a href="https://github.com/dennisdoomen/Piercer/blob/master/Build/default.ps1#L101">FluidCaching project</a>. Do notice that very <a href="https://github.com/gluck/il-repack/issues/109">recent versions</a> require .NET 4.6, so using the latest and greatest may complicate your build agent requirements. Regardless, we've run into some weird exceptional situations that neither could handle and which forced us to expose an internal dependency as a public dependency anyhow.  <p>So what about you? Does this all make sense? What kind of challenges did you run into while dealing with dependencies and how did you solve those? I'd love to hear your thoughts by commenting below. Oh, and follow me at <a href="https://twitter.com/ddoomen">@ddoomen</a> to get regular updates on my everlasting quest for better solutions.</p>